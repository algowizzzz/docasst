{% extends "base.html" %}

{% block title %}Document Review Cockpit{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/doc_review_cockpit.css') }}?v=20251115">
{% endblock %}

{% block content %}
<div id="docReviewApp" class="doc-cockpit" data-session-token="{{ session.token }}">
    <aside class="doc-panel doc-panel--left">
        <div class="panel-header">
            <div>
                <p class="eyebrow">Workspace</p>
                <h1>Document Review Cockpit</h1>
            </div>
            <button class="btn btn-sm btn-outline-secondary" id="btnRefreshDocs" title="Refresh documents">
                <i class="bi bi-arrow-clockwise"></i>
            </button>
        </div>

        <div class="panel-section">
            <div class="section-title">Upload location</div>
            <div class="upload-path">
                <code id="uploadDirDisplay">external/data/doc_review/uploads</code>
                <button class="btn btn-link btn-sm p-0 ms-2" id="btnOpenUploadDir">
                    <i class="bi bi-box-arrow-up-right"></i> View
                </button>
            </div>
            <label class="form-label small text-muted mt-3">Quick register (absolute path)</label>
            <div class="input-group input-group-sm">
                <input type="text" class="form-control" placeholder="/abs/path/document.pdf" id="inputSourcePath">
                <button class="btn btn-primary" id="btnRegisterDocument">
                    <i class="bi bi-plus-circle"></i>
                </button>
            </div>
            <small class="text-muted">Documents copied to the upload folder appear automatically.</small>
        </div>

        <div class="panel-section">
            <div class="section-title d-flex justify-content-between align-items-center">
                Documents
                <span class="badge rounded-pill bg-light text-dark" id="docCount">0</span>
            </div>
            <div class="input-with-icon mb-3">
                <i class="bi bi-search"></i>
                <input type="search" id="documentSearch" placeholder="Search documents">
            </div>
            <div class="doc-list" id="documentList">
                <div class="empty-state">Register a document to begin.</div>
            </div>
        </div>

        <div class="panel-section actions">
            <button class="btn btn-success w-100 mb-2" id="btnRunPhase1" disabled>
                <span class="spinner-border spinner-border-sm me-2 d-none" id="phase1Spinner"></span>
                <i class="bi bi-play-circle"></i> Run Phase 1 Analysis
            </button>
            <div class="d-grid gap-2">
                <button class="btn btn-outline-primary btn-sm" id="btnDownloadMarkdown" disabled>
                    <i class="bi bi-download"></i> Download Markdown
                </button>
                <button class="btn btn-outline-secondary btn-sm" id="btnOpenSource" disabled>
                    <i class="bi bi-file-earmark-text"></i> Open Source
                </button>
            </div>
        </div>
    </aside>

    <main class="doc-panel doc-panel--center">
        <section class="workspace-header" id="workspaceHeader">
            <div>
                <p class="eyebrow">Selected document</p>
                <h2 id="selectedDocTitle">No document selected</h2>
            </div>
            <div class="status-stack">
                <span class="status-chip" data-phase="phase1">Phase 1 ‚Ä¢ pending</span>
                <span class="status-chip" data-phase="phase2">Phase 2 ‚Ä¢ pending</span>
                <span class="status-chip" data-phase="phase3">Phase 3 ‚Ä¢ pending</span>
            </div>
        </section>

        <section class="metrics-grid" id="phase1Metrics">
            <div class="metric-card">
                <p>Pages</p>
                <h3 id="metricPages">‚Äî</h3>
            </div>
            <div class="metric-card">
                <p>Words</p>
                <h3 id="metricWords">‚Äî</h3>
            </div>
            <div class="metric-card">
                <p>Headings</p>
                <h3 id="metricHeadings">‚Äî</h3>
            </div>
            <div class="metric-card">
                <p>Images</p>
                <h3 id="metricImages">‚Äî</h3>
            </div>
        </section>

        <section class="card-stack">
            <article class="insight-card" id="execSummaryCard">
                <header>
                    <div>
                        <p class="eyebrow">Executive summary</p>
                        <h3>LLM snapshot</h3>
                    </div>
                    <span class="confidence-chip" id="summaryConfidence">awaiting run</span>
                </header>
                <div class="insight-body" id="execSummaryBody">
                    <p class="text-muted mb-0">Select a processed document to view the summary.</p>
                </div>
            </article>

            <article class="insight-card" id="tocCard">
                <header>
                    <div>
                        <p class="eyebrow">Structure review</p>
                        <h3>Table of contents health</h3>
                    </div>
                    <span class="score-chip" id="tocScore">‚Äî</span>
                </header>
                <div class="insight-body toc-body">
                    <div id="tocEntries" class="toc-list"></div>
                    <div class="split">
                        <div>
                            <p class="eyebrow">Observations</p>
                            <ul id="tocObservations" class="bullet-list"></ul>
                        </div>
                        <div>
                            <p class="eyebrow">Gaps</p>
                            <ul id="tocGaps" class="bullet-list bullet-list--warning"></ul>
                        </div>
                    </div>
                </div>
            </article>

            <article class="insight-card" id="templateFitnessCard">
                <header>
                    <div>
                        <p class="eyebrow">Template alignment</p>
                        <h3>Policy coverage</h3>
                    </div>
                    <span class="score-chip" id="templateAlignmentScore">‚Äî</span>
                </header>
                <div class="insight-body">
                    <div id="templateCategoryList" class="fitness-table"></div>
                </div>
            </article>

            <article class="insight-card" id="sectionStrategyCard">
                <header>
                    <div>
                        <p class="eyebrow">Next steps</p>
                        <h3>Section strategy</h3>
                    </div>
                    <span class="status-chip verdict" id="strategyVerdict">Awaiting analysis</span>
                </header>
                <div class="insight-body">
                    <p id="strategyRationale" class="text-muted">Run Phase 1 to receive actionable recommendations.</p>
                    <div class="strategy-grid">
                        <div>
                            <p class="eyebrow">Recommended level</p>
                            <h4 id="strategyLevel">‚Äî</h4>
                        </div>
                        <div>
                            <p class="eyebrow">Estimated sections</p>
                            <h4 id="strategySections">‚Äî</h4>
                        </div>
                    </div>
                    <p class="eyebrow mt-4 mb-2">Top remediation actions</p>
                    <ol id="strategyActions" class="next-step-list"></ol>
                </div>
            </article>
        </section>
    </main>

    <aside class="doc-panel doc-panel--right">
        <div class="panel-section">
            <div class="section-title d-flex justify-content-between align-items-center">
                Intelligence feed
                <button class="btn btn-sm btn-outline-secondary" id="btnRefreshWelcome" title="Refresh welcome message">
                    <i class="bi bi-arrow-clockwise"></i>
                </button>
            </div>
            <div class="welcome-body" id="welcomeMessage">
                <div class="skeleton skeleton-paragraph"></div>
                <div class="skeleton skeleton-paragraph"></div>
                <div class="skeleton skeleton-paragraph w-50"></div>
            </div>
        </div>

        <div class="panel-section chat-panel">
            <div class="section-title d-flex justify-content-between align-items-center">
                Agent chat
                <span class="badge bg-light text-dark" id="chatStatusBadge">idle</span>
            </div>
            <div class="chat-history" id="chatHistory">
                <div class="empty-state">Select a document and send a command to the agent.</div>
            </div>
            <div class="form-check form-switch my-2">
                <input class="form-check-input" type="checkbox" id="chatAutoExecute" checked>
                <label class="form-check-label" for="chatAutoExecute">Auto-execute plan steps</label>
            </div>
            <div class="chat-input">
                <textarea class="form-control" id="chatInput" rows="3" placeholder="Ask the agent e.g. 'Run a full review'"></textarea>
                <button class="btn btn-primary w-100 mt-2" id="btnSendChat">
                    <span class="spinner-border spinner-border-sm me-2 d-none" id="chatSpinner"></span>
                    Send
                </button>
            </div>
        </div>

        <div class="panel-section">
            <div class="section-title d-flex justify-content-between align-items-center">
                Execution trace
                <button class="btn btn-sm btn-outline-secondary" id="btnClearTimeline">
                    <i class="bi bi-trash"></i> Clear
                </button>
            </div>
            <div class="timeline-feed" id="timelineFeed">
                <div class="empty-state">Live workflow events will appear here.</div>
            </div>
        </div>
    </aside>
</div>
{% endblock %}

{% block extra_css %}
<style>
    .doc-sidebar {
        max-height: calc(100vh - 240px);
        overflow-y: auto;
    }
    .doc-markdown-editor {
        height: 420px;
        background-color: #0f172a;
        color: #e2e8f0;
        font-family: "Source Code Pro", monospace;
        font-size: 0.9rem;
        padding: 1rem;
        border-radius: 0.5rem;
        border: 1px solid #1e293b;
        resize: vertical;
    }
    .doc-markdown-editor:focus {
        outline: none;
        box-shadow: 0 0 0 0.2rem rgba(59, 130, 246, 0.35);
    }
    .doc-chat-history {
        height: 260px;
        overflow-y: auto;
    }
    .status-pill {
        display: inline-block;
        padding: 0.15rem 0.5rem;
        border-radius: 999px;
        font-size: 0.75rem;
        text-transform: capitalize;
    }
    .status-completed { background-color: #E6F2FF; color: #003DA5; }
    .status-running { background-color: #CCE5FF; color: #0052A5; }
    .status-error { background-color: #B3D9FF; color: #0066CC; }
    .status-new { background-color: #F0F7FF; color: #0052A5; }
    .status-ready { background-color: #E6F2FF; color: #003DA5; }
    .toc-preview {
        max-height: 220px;
        overflow-y: auto;
        font-size: 0.85rem;
        background-color: #f8fafc;
        padding: 0.75rem;
        border-radius: 0.5rem;
        border: 1px solid #e2e8f0;
    }
    .annotation-legend span {
        display: inline-block;
        padding: 0.2rem 0.5rem;
        border-radius: 0.4rem;
        margin-right: 0.5rem;
        font-size: 0.75rem;
    }
    .legend-original { background-color: #cbd5f5; }
    .legend-ai-title { background-color: #fde68a; }
    .legend-ai-comment { background-color: #fca5a5; }
    .nav-doc-review .nav-link {
        border-radius: 999px;
        margin-right: 0.5rem;
        font-weight: 500;
    }
    .nav-doc-review .nav-link.disabled {
        cursor: not-allowed;
        opacity: 0.6;
    }
    .chunk-preview-list {
        list-style: none;
        padding-left: 0;
        margin-bottom: 0;
    }
    .chunk-preview-list li {
        padding: 0.35rem 0.5rem;
        border-radius: 0.35rem;
        border: 1px solid #e5e7eb;
        background-color: #f8fafc;
        margin-bottom: 0.4rem;
        font-size: 0.85rem;
    }
    .chunk-preview-list li:last-child {
        margin-bottom: 0;
    }
    .chunk-pill {
        font-size: 0.75rem;
        background-color: #e0f2fe;
        color: #0369a1;
        border-radius: 999px;
        padding: 0.1rem 0.4rem;
        margin-left: 0.35rem;
    }
    .tab-helper {
        font-size: 0.85rem;
    }
</style>
{% endblock %}

{% block content %}
<div class="container-fluid">
    <div class="row mb-3 align-items-center">
        <div class="col-md-8">
            <h1 class="h3 mb-0"><i class="bi bi-diagram-3"></i> Document Review Cockpit</h1>
            <p class="text-muted mb-0">Run the predefined ingestion ‚Üí chunking ‚Üí mapping workflow and iterate with AI-assisted refinements.</p>
        </div>
        <div class="col-md-4 text-md-end mt-3 mt-md-0">
            <button id="btn-refresh" class="btn btn-outline-secondary">
                <i class="bi bi-arrow-clockwise"></i> Refresh
            </button>
        </div>
    </div>

    <div class="row g-3">
        <div class="col-12">
            <div class="card shadow-sm">
                <div class="card-header bg-light d-flex justify-content-between align-items-center">
                    <h5 class="mb-0"><i class="bi bi-info-circle"></i> Current Document Overview</h5>
                    <span class="small text-muted tab-helper">Select a document in Tab 1 to unlock the remaining workflow steps.</span>
                </div>
                <div class="card-body" id="overviewPanel">
                    <p class="text-muted mb-0">No document selected yet. Start in Tab 1 to upload or pick a document.</p>
                </div>
            </div>
        </div>
    </div>

    <ul class="nav nav-pills nav-doc-review mt-4" id="docReviewTabs" role="tablist">
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="tabButtonUpload" data-bs-toggle="tab" data-bs-target="#tab-upload" type="button" role="tab" aria-controls="tab-upload" aria-selected="true">
                1. Upload &amp; Select
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="tabButtonChunking" data-bs-toggle="tab" data-bs-target="#tab-chunking" type="button" role="tab" aria-controls="tab-chunking" aria-selected="false">
                2. Chunking &amp; Preview
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link disabled" id="tabButtonAnalysis" data-bs-toggle="tab" data-bs-target="#tab-analysis" type="button" role="tab" aria-controls="tab-analysis" aria-selected="false" disabled>
                3. Analysis Run
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link disabled" id="tabButtonReview" data-bs-toggle="tab" data-bs-target="#tab-review" type="button" role="tab" aria-controls="tab-review" aria-selected="false" disabled>
                4. Review &amp; Chat
            </button>
        </li>
    </ul>

    <div class="tab-content mt-3" id="docReviewTabContent">
        <div class="tab-pane fade show active" id="tab-upload" role="tabpanel" aria-labelledby="tabButtonUpload">
            <div class="row g-3">
                <div class="col-lg-6">
                    <div class="card shadow-sm h-100">
                        <div class="card-header text-white" style="background-color: #003DA5;">
                            <h5 class="mb-0"><i class="bi bi-cloud-arrow-up"></i> Document Upload &amp; Phase 1 Processing</h5>
                        </div>
                        <div class="card-body">
                            <div class="small mb-3 p-3" style="background-color: #E6F2FF; border-left: 3px solid #003DA5; border-radius: 0.25rem;">
                                <strong style="color: #003DA5;">üìÅ Upload Location:</strong><br>
                                <code id="uploadLocationDisplay" style="color: #0052A5; background-color: #F0F7FF;">external/data/doc_review/uploads</code><br>
                                <small style="color: #0066CC;">Drop your documents here or upload via the form below.</small>
                            </div>
                            
                            <!-- Document Dropdown -->
                            <div class="mb-3">
                                <label for="selectDocument" class="form-label">
                                    <strong>Select Document</strong>
                                </label>
                                <div class="input-group">
                                    <select class="form-select" id="selectDocument">
                                        <option value="">-- Select a document --</option>
                                    </select>
                                    <button class="btn btn-outline-secondary" type="button" id="btnRefreshDocList" title="Refresh document list">
                                        <i class="bi bi-arrow-clockwise"></i>
                                    </button>
                                </div>
                                <div class="form-text">Documents from: <code>external/data/doc_review/uploads</code></div>
                            </div>
                            
                            <!-- Upload Section -->
                            <div class="border-top pt-3 mb-3">
                                <label class="form-label" for="fileUploadInput">
                                    <strong>Upload New Document</strong>
                                </label>
                                <input type="file" id="fileUploadInput" class="form-control" accept=".pdf,.docx,.pptx,.md,.markdown,.txt">
                                <button type="button" class="btn btn-outline-primary mt-2 w-100" id="btnUploadLocal">
                                    <i class="bi bi-folder-plus"></i> Upload Document
                                </button>
                                <div class="form-text mt-2" id="uploadStatus">Files are saved to the upload location above.</div>
                            </div>
                            
                            <!-- Phase 1 Start Button -->
                            <div class="border-top pt-3">
                                <button type="button" class="btn btn-success w-100" id="btnRunPhase1" disabled>
                                    <i class="bi bi-play-circle"></i> Start Phase 1 Processing
                                </button>
                                <div class="form-text mt-2 small">
                                    Phase 1 runs: <code>detect_file_type ‚Üí convert_to_markdown ‚Üí extract_images ‚Üí compute_file_stats ‚Üí analyze_heading_structure ‚Üí build_file_metadata ‚Üí analyze_phase1_results</code>
                        </div>
                    </div>
                </div>
                    </div>
                </div>
                <div class="col-lg-6">
                    <div class="card shadow-sm h-100">
                        <div class="card-header bg-light d-flex justify-content-between align-items-center">
                            <h5 class="mb-0"><i class="bi bi-files"></i> Processed Documents</h5>
                            <button class="btn btn-sm btn-outline-secondary" id="btnRefreshProcessed">
                                <i class="bi bi-arrow-clockwise"></i> Refresh
                            </button>
                        </div>
                        <div class="card-body p-0">
                            <div class="doc-sidebar list-group list-group-flush" id="documentsList">
                                <div class="list-group-item text-muted small text-center">No processed documents yet.</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Phase 1 Summary Section -->
            <div class="row g-3 mt-3" id="phase1SummaryRow" style="display: none;">
                <div class="col-12">
                    <div class="card shadow-sm">
                        <div class="card-header text-white d-flex justify-content-between align-items-center" style="background-color: #0052A5;">
                            <h5 class="mb-0"><i class="bi bi-graph-up"></i> Phase 1 Ingestion Summary</h5>
                            <button class="btn btn-sm btn-light" type="button" data-bs-toggle="collapse" data-bs-target="#phase1SummaryCollapse" aria-expanded="true">
                                <i class="bi bi-chevron-down"></i>
                            </button>
                        </div>
                        <div class="collapse show" id="phase1SummaryCollapse">
                            <div class="card-body">
                                <div id="phase1SummaryContent">
                                    <div class="text-center text-muted">
                                        <p>Select a document to view Phase 1 summary</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-pane fade" id="tab-chunking" role="tabpanel" aria-labelledby="tabButtonChunking">
            <div class="row g-3">
                <div class="col-lg-7">
                    <div class="card shadow-sm h-100">
                        <div class="card-header bg-light d-flex justify-content-between align-items-center">
                            <div>
                                <h5 class="mb-0">Chunking Controls</h5>
                                <small class="text-muted">Adjust thresholds and strategies, then apply to regenerate chunks via deterministic MCP tools.</small>
                            </div>
                            <button id="btn-save-config" class="btn btn-sm btn-primary" disabled>
                                <i class="bi bi-arrow-repeat"></i> Apply Chunking
                            </button>
                        </div>
                        <div class="card-body">
                            <form id="config-form">
                                <!-- Document Selection for Phase 2 -->
                                <div class="mb-3 pb-3 border-bottom">
                                    <label for="selectDocumentPhase2" class="form-label">
                                        <strong>Select Document</strong>
                                    </label>
                                    <select class="form-select" id="selectDocumentPhase2">
                                        <option value="">-- Select a document --</option>
                                    </select>
                                    <small class="form-text text-muted">Documents that have completed Phase 1</small>
                                    </div>
                                
                                <fieldset id="chunking-fieldset" disabled>
                                    <div class="row g-3 align-items-end">
                                        <div class="col-md-4">
                                            <label class="form-label">Page threshold</label>
                                            <input type="number" min="1" id="inputPageThreshold" class="form-control" value="10">
                                            <small class="form-text text-muted">Documents with this many pages or more will be chunked</small>
                                        </div>
                                        <div class="col-md-4">
                                            <label class="form-label">Context aware level</label>
                                            <select id="selectContextLevel" class="form-select">
                                                <option value="h1" selected>H1</option>
                                                <option value="h2">H2</option>
                                                <option value="h3">H3</option>
                                                <option value="h4">H4</option>
                                                <option value="h5">H5</option>
                                                <option value="h6">H6</option>
                                            </select>
                                            <small class="form-text text-muted">Heading level used for chunking boundaries</small>
                                        </div>
                                        <div class="col-md-4">
                                            <label class="form-label">Estimated chunk count</label>
                                            <input type="text" id="inputEstimatedChunks" class="form-control" readonly placeholder="Apply chunking to estimate">
                                            <small class="form-text text-muted">Preview of chunks that will be created</small>
                                        </div>
                                    </div>
                                </fieldset>
                            </form>
                        </div>
                    </div>
                </div>
                <div class="col-lg-5">
                    <div class="card shadow-sm h-100">
                        <div class="card-header bg-light d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">Chunk Preview</h5>
                            <span class="small text-muted">Summaries from `build_index` output.</span>
                        </div>
                        <div class="card-body" id="chunkPreviewPanel">
                            <p class="text-muted mb-0">Apply chunking to see section counts, headings, and token estimates.</p>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-pane fade" id="tab-analysis" role="tabpanel" aria-labelledby="tabButtonAnalysis">
            <div class="row g-3">
                <div class="col-lg-7">
                    <div class="card shadow-sm">
                        <div class="card-header bg-light">
                            <h5 class="mb-0">Template &amp; AI Controls</h5>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label for="selectDocumentPhase3" class="form-label">
                                    <strong>Select Document</strong>
                                </label>
                                <select class="form-select" id="selectDocumentPhase3">
                                    <option value="">-- Select a document --</option>
                                </select>
                                <small class="form-text text-muted">Documents that have completed Phase 2 (chunking & indexing)</small>
                            </div>
                            <hr>
                            <fieldset id="template-fieldset" disabled>
                                <div class="row g-3 align-items-end">
                                    <div class="col-md-8">
                                        <label class="form-label">Template</label>
                                        <select id="selectTemplate" class="form-select"></select>
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label">TOC level</label>
                                        <select id="selectTocLevel" class="form-select">
                                            <option value="h1">H1</option>
                                            <option value="h2" selected>H2</option>
                                            <option value="h3">H3</option>
                                        </select>
                                    </div>
                                </div>
                                <div class="form-check mt-3">
                                    <input class="form-check-input" type="checkbox" id="toggleLateAppend" checked>
                                    <label class="form-check-label" for="toggleLateAppend">Attempt late mapping for relevant unmapped sections</label>
                                </div>
                            </fieldset>
                            <div class="mt-3 small border rounded p-2 bg-light" id="templatePreview">
                                Select a template to preview its outline here.
                            </div>
                            <hr>
                            <fieldset id="llm-fieldset" disabled>
                                <div class="row g-3">
                                    <div class="col-md-8">
                                        <label class="form-label">LLM model</label>
                                        <input type="text" id="inputLlmModel" class="form-control" placeholder="claude-3-opus-20240229">
                                    </div>
                                    <div class="col-md-4">
                                        <label class="form-label">Temperature</label>
                                        <input type="number" id="inputLlmTemperature" class="form-control" min="0" max="1" step="0.05" value="0.2">
                                    </div>
                                </div>
                            </fieldset>
                            <hr>
                            <fieldset id="ui-fieldset" disabled>
                                <div class="row g-3">
                                    <div class="col-md-8">
                                        <label class="form-label">Heading for appended sections</label>
                                        <input type="text" id="inputUiAppendHeading" class="form-control" placeholder="Additional Sections">
                                    </div>
                                    <div class="col-md-4 d-flex align-items-end">
                                        <div class="form-check">
                                            <input class="form-check-input" type="checkbox" id="toggleUiTitleHighlight" checked>
                                            <label class="form-check-label" for="toggleUiTitleHighlight">Highlight AI titles</label>
                                        </div>
                                    </div>
                                </div>
                                <div class="form-check mt-2">
                                    <input class="form-check-input" type="checkbox" id="toggleUiComments" checked>
                                    <label class="form-check-label" for="toggleUiComments">Show AI comments panel</label>
                                </div>
                            </fieldset>
                        </div>
                    </div>
                </div>
                <div class="col-lg-5">
                    <div class="card shadow-sm h-100">
                        <div class="card-header bg-light d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">Workflow Execution</h5>
                            <button id="btn-run" class="btn btn-sm btn-warning" disabled>
                                <i class="bi bi-play-fill"></i> Phase 3 Submit
                            </button>
                        </div>
                        <div class="card-body">
                            <p class="small text-muted">This run executes the LangGraph nodes (heading mapping, title improvements, relevancy scoring, second-pass mapping) then calls deterministic MCP tools for TOC generation, document assembly, and UI annotations.</p>
                            <div id="logsPanel" class="small text-muted border rounded p-2" style="max-height:220px; overflow-y:auto;">
                                <em>No logs yet</em>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Phase 3 Stats & Analysis Section -->
            <div class="row g-3 mt-3" id="phase3SummaryRow" style="display: none;">
                <div class="col-12">
                    <div class="card shadow-sm">
                        <div class="card-header bg-light">
                            <h5 class="mb-0"><i class="bi bi-bar-chart"></i> Phase 3 Mapping Results</h5>
                        </div>
                        <div class="card-body" id="phase3SummaryContent">
                            <em class="text-muted">Run Phase 3 to see mapping statistics and analysis.</em>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="tab-pane fade" id="tab-review" role="tabpanel" aria-labelledby="tabButtonReview">
            <div class="row g-3 mb-3">
                <div class="col-12">
                    <div class="card shadow-sm">
                        <div class="card-header bg-light">
                            <h5 class="mb-0"><i class="bi bi-file-text"></i> Phase 4: Output Artefacts</h5>
                            <small class="text-muted">Generate TOC, assemble improved markdown, and prepare UI annotations</small>
                        </div>
                        <div class="card-body">
                            <div class="row g-3">
                                <div class="col-md-6">
                                    <label for="selectDocumentPhase4" class="form-label">
                                        <strong>Select Document</strong>
                                    </label>
                                    <select class="form-select" id="selectDocumentPhase4">
                                        <option value="">-- Select a document --</option>
                                    </select>
                                    <small class="form-text text-muted">Documents that have completed Phase 2 (chunking & indexing)</small>
                                </div>
                                <div class="col-md-6 d-flex align-items-end">
                                    <button id="btn-run-phase4" class="btn btn-primary" type="button" disabled>
                                        <i class="bi bi-play-circle"></i> Run Phase 4
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="row g-3">
                <div class="col-lg-7">
                    <div class="card shadow-sm mb-3">
                        <div class="card-header bg-light d-flex justify-content-between align-items-center flex-wrap gap-2">
                            <h5 class="mb-0">Improved Markdown</h5>
                            <div class="d-flex align-items-center gap-2">
                                <div class="annotation-legend small text-muted">
                                    <span class="legend-original">Original</span>
                                    <span class="legend-ai-title">AI title</span>
                                    <span class="legend-ai-comment">Comment</span>
                                </div>
                                <button id="btn-save-markdown" class="btn btn-sm btn-success" disabled>
                                    <i class="bi bi-save"></i> Save Markdown
                                </button>
                            </div>
                        </div>
                        <div class="card-body">
                            <textarea class="form-control doc-markdown-editor" id="markdownEditor" placeholder="Run Phase 4 to populate improved markdown for editing." disabled></textarea>
                            <div class="toc-preview mt-3" id="tocPreview"></div>
                        </div>
                    </div>
                </div>
                <div class="col-lg-5">
                    <div class="card shadow-sm h-100">
                        <div class="card-header bg-light d-flex justify-content-between align-items-center">
                            <h5 class="mb-0">Chat with Review Agent</h5>
                            <button id="btn-attach-selection" class="btn btn-sm btn-outline-primary" type="button" disabled title="Attach selected text from markdown">
                                <i class="bi bi-paperclip"></i> Attach Selection
                            </button>
                        </div>
                        <div class="card-body d-flex flex-column">
                            <div class="doc-chat-history border rounded p-2 mb-2 flex-grow-1" id="chatHistory"></div>
                            <!-- Attached Text Display -->
                            <div id="attachedTextDisplay" class="mb-2 p-2 border rounded" style="display: none; background-color: #F0F7FF; max-height: 120px; overflow-y: auto;">
                                <div class="d-flex justify-content-between align-items-start mb-1">
                                    <small class="text-muted fw-bold">
                                        <i class="bi bi-paperclip"></i> Attached Text:
                                    </small>
                                    <button id="btn-remove-attachment" class="btn btn-sm p-0" type="button" title="Remove attachment" style="color: #0066CC;">
                                        <i class="bi bi-x-circle"></i>
                                    </button>
                                </div>
                                <div id="attachedTextPreview" class="small text-muted" style="color: #0052A5; white-space: pre-wrap; word-break: break-word;"></div>
                            </div>
                            <form id="chat-form" class="d-flex gap-2">
                                <input type="text" id="inputChat" class="form-control" placeholder="Ask about the document..." required>
                                <button class="btn btn-outline-primary" type="submit">
                                    <i class="bi bi-send"></i>
                                </button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
console.info('[DocReview][inline-version]', '2025-11-13T21:15:00Z');
const documentsListEl = document.getElementById('documentsList');
const overviewPanel = document.getElementById('overviewPanel');
const logsPanel = document.getElementById('logsPanel');
const markdownEditor = document.getElementById('markdownEditor');
const saveMarkdownButton = document.getElementById('btn-save-markdown');
const tocPreview = document.getElementById('tocPreview');
const templatesSelect = document.getElementById('selectTemplate');
const chatHistory = document.getElementById('chatHistory');
const attachedTextDisplay = document.getElementById('attachedTextDisplay');
const attachedTextPreview = document.getElementById('attachedTextPreview');
const btnAttachSelection = document.getElementById('btn-attach-selection');
const btnRemoveAttachment = document.getElementById('btn-remove-attachment');
let attachedText = ''; // Store attached text for chat
const templatePreview = document.getElementById('templatePreview');
const fileUploadInput = document.getElementById('fileUploadInput');
const uploadStatus = document.getElementById('uploadStatus');
const uploadButton = document.getElementById('btnUploadLocal');
const selectDocumentDropdown = document.getElementById('selectDocument');
const selectDocumentPhase2 = document.getElementById('selectDocumentPhase2');
const selectDocumentPhase3 = document.getElementById('selectDocumentPhase3');
const selectDocumentPhase4 = document.getElementById('selectDocumentPhase4');
const btnRunPhase4 = document.getElementById('btn-run-phase4');
const btnRefreshDocList = document.getElementById('btnRefreshDocList');
const btnRunPhase1 = document.getElementById('btnRunPhase1');
const btnRefreshProcessed = document.getElementById('btnRefreshProcessed');
const uploadLocationDisplay = document.getElementById('uploadLocationDisplay');
const chunkPreviewPanel = document.getElementById('chunkPreviewPanel');
const estimatedChunksInput = document.getElementById('inputEstimatedChunks');
const applyBtn = document.getElementById('btn-save-config');
const tabControls = {
    chunking: document.getElementById('tabButtonChunking'),
    analysis: document.getElementById('tabButtonAnalysis'),
    review: document.getElementById('tabButtonReview')
};

let activeDocumentId = null;
let activeDocument = null;
let markdownDirty = false;
const templateCache = {};
let liveLogs = [];
let currentLogRoom = null;
let pendingLogRoom = null;

function setWorkflowTabsEnabled(enabled) {
    // Always allow Phase 2 and Phase 3 tabs if documents exist (checked separately)
    Object.entries(tabControls).forEach(([key, btn]) => {
        if (!btn) return;
        // Phase 2 (chunking) tab can be enabled independently if documents with Phase 1 exist
        if (key === 'chunking') {
            // Don't disable Phase 2 tab here - it's managed by checkPhase2Availability
            return;
        }
        // Phase 3 (analysis) tab can be enabled independently if documents with Phase 2 exist
        if (key === 'analysis') {
            // Don't disable Phase 3 tab here - it's managed by checkPhase3Availability
            return;
        }
        btn.disabled = !enabled;
        btn.classList.toggle('disabled', !enabled);
    });
}

function showTab(targetId) {
    const trigger = document.querySelector(`[data-bs-target="${targetId}"]`);
    if (!trigger || typeof bootstrap === 'undefined' || !bootstrap.Tab) return;
    bootstrap.Tab.getOrCreateInstance(trigger).show();
}

function toggleConfigFieldsets(enabled) {
    ['chunking-fieldset', 'template-fieldset', 'llm-fieldset', 'ui-fieldset'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.disabled = !enabled;
    });
    const runBtn = document.getElementById('btn-run');
    if (runBtn) runBtn.disabled = !enabled;
    if (applyBtn) applyBtn.disabled = !enabled;
}

function highlightActiveDocument() {
    if (!documentsListEl) return;
    Array.from(documentsListEl.querySelectorAll('.list-group-item')).forEach(item => {
        if (!item.dataset.fileId) return;
        item.classList.toggle('active', item.dataset.fileId === activeDocumentId);
    });
}

async function ensureSocketToken() {
    let token = typeof getSessionToken === 'function' ? getSessionToken() : null;
    if (token) {
        if (typeof socket !== 'undefined' && socket) {
            try {
                socket.emit('authenticate', { token });
            } catch (err) {
                console.warn('Failed to re-authenticate existing socket', err);
            }
        }
        return token;
    }
    try {
        const res = await fetch('/api/doc_review/token');
        if (!res.ok) {
            return null;
        }
        const data = await res.json();
        if (data.token) {
            if (typeof sessionStorage !== 'undefined') {
                sessionStorage.setItem('mcp_token', data.token);
            }
            document.cookie = `mcp_token=${data.token}; path=/`;
            if (typeof socket !== 'undefined' && socket) {
                try {
                    socket.emit('authenticate', { token: data.token });
                    if (socket.disconnected) {
                        socket.connect();
                    }
                } catch (err) {
                    console.warn('Failed to authenticate socket with fetched token', err);
                }
            }
            return data.token;
        }
    } catch (err) {
        console.error('Failed to fetch doc review token', err);
    }
    return null;
}

function statusPill(status) {
    const normalized = (status || 'new').toLowerCase();
    const classMap = {
        completed: 'status-completed',
        running: 'status-running',
        error: 'status-error',
        new: 'status-new',
        ready: 'status-ready'
    };
    return `<span class="status-pill ${classMap[normalized] || 'status-new'}">${normalized}</span>`;
}

async function loadTemplates() {
    try {
        const res = await fetch('/api/doc_review/templates');
        const data = await res.json();
        templatesSelect.innerHTML = '';
        data.templates.forEach(t => {
            const option = document.createElement('option');
            option.value = t.template_id;
            option.textContent = `${t.template_id} (${Math.round(t.size/1024)} KB)`;
            templatesSelect.appendChild(option);
            templateCache[t.template_id] = { summary: t };
        });
    } catch (err) {
        console.error('Failed to load templates', err);
    }
}

async function loadDocuments() {
    try {
        const res = await fetch('/api/doc_review/documents');
        const data = await res.json();
        documentsListEl.innerHTML = '';
        if (!Array.isArray(data.documents) || !data.documents.length) {
            const placeholder = document.createElement('div');
            placeholder.className = 'list-group-item text-muted small text-center';
            placeholder.textContent = 'No documents ingested yet.';
            documentsListEl.appendChild(placeholder);
            if (!activeDocumentId) {
                setWorkflowTabsEnabled(false);
                toggleConfigFieldsets(false);
            }
            return;
        }
        let hasActive = false;
        data.documents.forEach(doc => {
            const item = document.createElement('button');
            item.type = 'button';
            item.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
            item.dataset.fileId = doc.file_id;
            if (doc.file_id === activeDocumentId) {
                item.classList.add('active');
                hasActive = true;
            }
            item.innerHTML = `<div>
                <div class="fw-semibold">${doc.file_id}</div>
                <div class="small text-muted">${doc.file_metadata?.page_count || 0} pages ‚Ä¢ ${doc.file_metadata?.word_count || 0} words</div>
            </div>
            ${statusPill(doc.status)}`;
            item.addEventListener('click', () => selectDocument(doc.file_id));
            documentsListEl.appendChild(item);
        });
        if (!hasActive) {
            activeDocumentId = null;
            activeDocument = null;
            setWorkflowTabsEnabled(false);
            toggleConfigFieldsets(false);
            overviewPanel.innerHTML = '<p class="text-muted mb-0">No document selected yet. Start in Tab 1 to upload or pick a document.</p>';
            document.getElementById('phase1SummaryRow').style.display = 'none';
            markdownEditor.value = 'Run the workflow to populate improved markdown for editing.';
            markdownEditor.disabled = true;
            saveMarkdownButton.disabled = true;
            tocPreview.textContent = '';
            chunkPreviewPanel.innerHTML = '<p class="text-muted mb-0">Apply chunking to see section counts, headings, and token estimates.</p>';
        } else {
            highlightActiveDocument();
        }
    } catch (err) {
        console.error('Failed to load documents', err);
    }
}

function renderOverview(state) {
    // Load Phase 1 summary which will override this overview
    if (activeDocumentId && state && state.file_id) {
        // Load Phase 1 summary asynchronously - it will update overviewPanel
        loadPhase1Summary(activeDocumentId).catch(() => {
            // If loading fails, show fallback
            renderOverviewFallback(state);
        });
    } else {
        renderOverviewFallback(state);
    }
}

function renderOverviewFallback(state) {
    // Fallback if Phase 1 not completed yet
    const metadata = state.state?.file_metadata || {};
    const chunking = metadata.chunking || {};
    const headingLevels = metadata.heading_levels || [];
    overviewPanel.innerHTML = `
        <div class="d-flex justify-content-between align-items-center mb-2">
            <h6 class="mb-0">${state.file_id}</h6>
            ${statusPill(state.status)}
        </div>
        <dl class="row small">
            <dt class="col-5">Source path</dt>
            <dd class="col-7 text-truncate" title="${state.source_path}">${state.source_path}</dd>
            <dt class="col-5">File type</dt>
            <dd class="col-7">${metadata.file_type || state.state?.file_type || 'unknown'}</dd>
            <dt class="col-5">Pages / Words</dt>
            <dd class="col-7">${metadata.page_count || 0} / ${metadata.word_count || 0}</dd>
            <dt class="col-5">Heading levels</dt>
            <dd class="col-7">${headingLevels.join(', ') || 'n/a'}</dd>
            <dt class="col-5">Chunking</dt>
            <dd class="col-7">${chunking.strategy || 'none'} ‚Ä¢ should_chunk=${chunking.should_chunk}</dd>
            <dt class="col-5">Updated</dt>
            <dd class="col-7">${state.updated_at || 'n/a'}</dd>
        </dl>
        <div class="alert alert-info mt-3 mb-0 small">
            <i class="bi bi-info-circle"></i> Run the workflow to generate Phase 1 analysis report.
        </div>
    `;
}

function renderMarkdown(state) {
    const markdown = state.state?.improved_markdown;
    if (markdown) {
        markdownEditor.value = markdown;
        markdownEditor.disabled = false;
        markdownDirty = false;
        saveMarkdownButton.disabled = true;
    } else {
        markdownEditor.value = 'Run the workflow to populate improved markdown for editing.';
        markdownEditor.disabled = true;
        markdownDirty = false;
        saveMarkdownButton.disabled = true;
    }
    const tocEntries = state.state?.index?.toc || [];
    if (tocEntries.length) {
        tocPreview.innerHTML = tocEntries.map(entry => `
            <div>${(entry.order ?? 0) + 1}. ${entry.heading}</div>
        `).join('');
    } else {
        tocPreview.textContent = 'Table of contents will appear after a successful run.';
    }
}

function renderChunkPreview(state) {
    console.log('renderChunkPreview: Called with state:', state);
    if (!chunkPreviewPanel) {
        console.error('renderChunkPreview: chunkPreviewPanel not found');
        return;
    }
    const chunks = Array.isArray(state?.state?.chunks) ? state.state.chunks : [];
    console.log('renderChunkPreview: Chunks found:', chunks.length);
    const chunking = state?.state?.file_metadata?.chunking || state?.state?.chunking_decision || {};
    if (estimatedChunksInput) {
        estimatedChunksInput.value = chunks.length ? String(chunks.length) : '';
    }
    if (!chunks.length) {
        chunkPreviewPanel.innerHTML = `
            <p class="text-muted mb-2">No chunk data available. Apply chunking on this tab to generate preview from the latest deterministic pass.</p>
            <div class="alert alert-info py-2 px-3 mb-0 small">Chunk summaries will list section headings, hierarchy, and estimated tokens.</div>
        `;
        return;
    }
    const total = chunks.length;
    const tokenCounts = chunks.map(c => c.token_count).filter(v => typeof v === 'number');
    const avgTokens = tokenCounts.length ? Math.round(tokenCounts.reduce((sum, val) => sum + val, 0) / tokenCounts.length) : 'n/a';
    const maxTokens = tokenCounts.length ? Math.max(...tokenCounts) : 'n/a';
    const strategy = chunking.strategy || 'unknown';
    const shouldChunk = chunking.should_chunk ?? true;
    const previewItems = chunks.slice(0, 6).map(chunk => {
        const heading = chunk.heading_path?.length ? chunk.heading_path.join(' ‚Ä∫ ') : (chunk.heading_text_original || `Chunk ${chunk.order ?? 0}`);
        const order = (chunk.order ?? 0) + 1;
        const tokens = typeof chunk.token_count === 'number' ? `${chunk.token_count} tokens` : 'tokens n/a';
        return `<li>
            <strong>#${order}</strong> ${heading}
            <span class="chunk-pill">${tokens}</span>
        </li>`;
    }).join('');
    const extraNote = total > 6 ? `<p class="small text-muted mb-0">Showing first 6 of ${total} chunks.</p>` : '';
    chunkPreviewPanel.innerHTML = `
        <div class="mb-2">
            <span class="badge bg-primary-subtle text-primary-emphasis me-2">Strategy: ${strategy}</span>
            <span class="badge bg-secondary-subtle text-secondary-emphasis me-2">should_chunk=${shouldChunk}</span>
            <span class="badge bg-info-subtle text-info-emphasis">Avg tokens: ${avgTokens} ‚Ä¢ Max: ${maxTokens}</span>
        </div>
        <ul class="chunk-preview-list">${previewItems}</ul>
        ${extraNote}
    `;
}

function normaliseLogEntry(entry) {
    if (!entry) {
        return { node: 'workflow', message: '', level: 'info', timestamp: null };
    }
    if (typeof entry === 'string') {
        const parts = entry.split(':');
        const node = parts.length > 1 ? parts.shift() : 'workflow';
        const message = parts.join(':').trim() || entry;
        const level = entry.toLowerCase().includes('error') ? 'error' : 'info';
        return { node, message, level, timestamp: null };
    }
    return {
        node: entry.node || 'workflow',
        message: entry.message || '',
        level: entry.level || 'info',
        timestamp: entry.timestamp || null,
    };
}

function updateLogsPanel() {
    if (!liveLogs.length) {
        logsPanel.innerHTML = '<em>No logs yet</em>';
        return;
    }
    logsPanel.innerHTML = liveLogs
        .map(entry => {
            const time = entry.timestamp ? new Date(entry.timestamp).toLocaleTimeString() : '';
            const levelClass =
                entry.level === 'error'
                    ? 'text-danger'
                    : entry.level === 'warning'
                    ? 'text-warning'
                    : 'text-muted';
            const nodeLabel = entry.node ? `<strong>${entry.node}</strong>` : '';
            return `<div class="small ${levelClass}">${time ? `[${time}] ` : ''}${nodeLabel}${nodeLabel ? ': ' : ''}${entry.message}</div>`;
        })
        .join('');
    logsPanel.scrollTop = logsPanel.scrollHeight;
}

function renderLogs(state) {
    const logs = state.state?.logs || [];
    liveLogs = logs.map(normaliseLogEntry);
    updateLogsPanel();
}

function subscribeToLogs(fileId) {
    if (!fileId) return;
    pendingLogRoom = fileId;
    if (typeof socket !== 'undefined' && socket && isAuthenticated) {
        joinDocLogRoom(fileId);
    }
}

async function joinDocLogRoom(fileId) {
    if (!socket || !isAuthenticated || !fileId) return;
    const token = await ensureSocketToken();
    if (!token) return;
    if (currentLogRoom && currentLogRoom !== fileId) {
        socket.emit('doc_review:leave', { token, file_id: currentLogRoom });
    }
    socket.emit('doc_review:join', { token, file_id: fileId });
    currentLogRoom = fileId;
    pendingLogRoom = null;
}

async function leaveDocLogRoom() {
    if (!socket || !isAuthenticated || !currentLogRoom) return;
    const token = await ensureSocketToken();
    if (!token) return;
    socket.emit('doc_review:leave', { token, file_id: currentLogRoom });
    currentLogRoom = null;
}

function handleDocReviewLog(data) {
    if (!data || data.file_id !== activeDocumentId) return;
    const entry = normaliseLogEntry(data);
    liveLogs.push(entry);
    if (liveLogs.length > 200) {
        liveLogs = liveLogs.slice(-200);
    }
    updateLogsPanel();
}

function handleDocReviewStatus(data) {
    if (!data || data.file_id !== activeDocumentId) return;
    if (data.status && activeDocument) {
        activeDocument.status = data.status;
        renderOverview(activeDocument);
    }
    if (data.message) {
        liveLogs.push(
            normaliseLogEntry({
                node: data.status || 'status',
                message: data.message,
                level: data.status === 'error' ? 'error' : 'info',
                timestamp: data.timestamp,
            })
        );
        if (liveLogs.length > 200) {
            liveLogs = liveLogs.slice(-200);
        }
        updateLogsPanel();
    }
}

function renderTemplatePreview(templateData) {
    if (!templateData) {
        templatePreview.textContent = 'Select a template to preview its outline here.';
        return;
    }
    const sections = templateData.sections || [];
    if (!sections.length) {
        templatePreview.textContent = 'Template has no defined sections.';
        return;
    }
    const lines = [];
    const walk = (items, depth = 0) => {
        items.forEach(item => {
            const indent = '&nbsp;'.repeat(depth * 4);
            const title = item.title || item.id;
            lines.push(`${indent}‚Ä¢ ${title} (${item.level})`);
            if (Array.isArray(item.children) && item.children.length) {
                walk(item.children, depth + 1);
            }
        });
    };
    walk(sections);
    templatePreview.innerHTML = lines.join('<br>');
}

async function refreshTemplatePreview(templateId) {
    if (!templateId) {
        renderTemplatePreview(null);
        return;
    }
    if (templateCache[templateId]?.content) {
        renderTemplatePreview(templateCache[templateId].content);
        return;
    }
    try {
        const res = await fetch(`/api/doc_review/templates/${templateId}`);
        if (!res.ok) throw new Error(`Template fetch failed: ${res.status}`);
        const data = await res.json();
        templateCache[templateId] = { ...(templateCache[templateId] || {}), content: data.content };
        renderTemplatePreview(data.content);
    } catch (err) {
        console.error('Failed to load template detail', err);
        templatePreview.textContent = 'Unable to load template preview.';
    }
}

function renderChatHistory(entries) {
    if (!chatHistory) return;
    chatHistory.innerHTML = '';
    const list = Array.isArray(entries) ? entries : [];
    if (!list.length) {
        chatHistory.innerHTML = '<em>No interactions yet.</em>';
        return;
    }
    list.forEach(entry => {
        const wrapper = document.createElement('div');
        wrapper.className = 'mb-2';
        const humanTimestamp = entry.timestamp ? new Date(entry.timestamp).toLocaleString() : 'Just now';
        const userLine = document.createElement('div');
        userLine.className = 'fw-semibold';
        userLine.textContent = `You (${humanTimestamp}):`;
        const userMsg = document.createElement('div');
        userMsg.className = 'mb-1';
        userMsg.textContent = entry.message || '';
        wrapper.appendChild(userLine);
        wrapper.appendChild(userMsg);
        if (entry.selection) {
            const selectionBlock = document.createElement('div');
            selectionBlock.className = 'small text-muted fst-italic mb-1';
            selectionBlock.textContent = `Selection: ${entry.selection}`;
            wrapper.appendChild(selectionBlock);
        }
        const agentLine = document.createElement('div');
        agentLine.className = 'fw-semibold';
        agentLine.textContent = 'Agent:';
        const agentMsg = document.createElement('div');
        agentMsg.textContent = entry.response || '';
        wrapper.appendChild(agentLine);
        wrapper.appendChild(agentMsg);
        chatHistory.appendChild(wrapper);
    });
    chatHistory.scrollTop = chatHistory.scrollHeight;
}

// Enhanced renderChatHistory that shows attachment indicators
function renderChatHistoryWithAttachments(entries) {
    if (!chatHistory) return;
    chatHistory.innerHTML = '';
    const list = Array.isArray(entries) ? entries : [];
    if (!list.length) {
        chatHistory.innerHTML = '<em>No interactions yet.</em>';
        return;
    }
    
    list.forEach((entry, idx) => {
        // Handle old format: single entry with both message and response
        if (entry.message !== undefined && entry.response !== undefined) {
            // User message
            const userWrapper = document.createElement('div');
            userWrapper.className = 'mb-2 text-end';
            const userBubble = document.createElement('div');
            userBubble.className = 'd-inline-block p-2 rounded bg-primary text-white';
            userBubble.style.maxWidth = '85%';
            userBubble.style.fontSize = '0.9rem';
            userBubble.style.wordWrap = 'break-word';
            
            let userContent = entry.message || '';
            if (entry.selection || entry.selected_text) {
                const attachmentPreview = entry.selection || entry.selected_text || '';
                userBubble.innerHTML = `
                    <div class="mb-1" style="opacity: 0.9;">
                        <small><i class="bi bi-paperclip"></i> Attached: ${attachmentPreview.length > 80 ? attachmentPreview.substring(0, 80) + '...' : attachmentPreview}</small>
                    </div>
                    <div>${(userContent || '').replace(/\n/g, '<br>')}</div>
                `;
            } else {
                userBubble.innerHTML = (userContent || '').replace(/\n/g, '<br>');
            }
            userWrapper.appendChild(userBubble);
            chatHistory.appendChild(userWrapper);
            
            // Assistant response
            if (entry.response) {
                const assistantWrapper = document.createElement('div');
                assistantWrapper.className = 'mb-2 text-start';
                const assistantBubble = document.createElement('div');
                assistantBubble.className = 'd-inline-block p-2 rounded bg-light text-dark';
                assistantBubble.style.maxWidth = '85%';
                assistantBubble.style.fontSize = '0.9rem';
                assistantBubble.style.wordWrap = 'break-word';
                assistantBubble.innerHTML = (entry.response || '(Empty response)').replace(/\n/g, '<br>');
                assistantWrapper.appendChild(assistantBubble);
                chatHistory.appendChild(assistantWrapper);
            }
            return; // Skip the rest for old format
        }
        
        // Handle new format: separate entries with role/content
        const isUser = entry.role === 'user';
        const isAssistant = entry.role === 'assistant';
        
        if (!isUser && !isAssistant) {
            // Skip entries without a recognized role
            console.warn('Unknown chat entry format:', entry);
            return;
        }
        
        const wrapper = document.createElement('div');
        wrapper.className = `mb-2 ${isUser ? 'text-end' : 'text-start'}`;
        
        const bubble = document.createElement('div');
        bubble.className = `d-inline-block p-2 rounded ${isUser ? 'bg-primary text-white' : 'bg-light text-dark'}`;
        bubble.style.maxWidth = '85%';
        bubble.style.fontSize = '0.9rem';
        bubble.style.wordWrap = 'break-word';
        
        // Get content
        const content = entry.content || (isUser ? entry.message : entry.response) || '';
        
        if (!content && isAssistant) {
            console.warn('Empty assistant response in chat entry:', entry);
        }
        
        // Show attachment indicator for user messages
        if (isUser && (entry.selection || entry.selected_text)) {
            const attachmentPreview = entry.selection || entry.selected_text || '';
            bubble.innerHTML = `
                <div class="mb-1" style="opacity: 0.9;">
                    <small><i class="bi bi-paperclip"></i> Attached: ${attachmentPreview.length > 80 ? attachmentPreview.substring(0, 80) + '...' : attachmentPreview}</small>
                </div>
                <div>${(content || '').replace(/\n/g, '<br>')}</div>
            `;
        } else {
            // For assistant responses, use innerHTML to support line breaks
            bubble.innerHTML = (content || (isAssistant ? '(Empty response)' : '')).replace(/\n/g, '<br>');
        }
        
        wrapper.appendChild(bubble);
        chatHistory.appendChild(wrapper);
    });
    
    chatHistory.scrollTop = chatHistory.scrollHeight;
}

async function populateConfigForm(state) {
    const cfg = state.state?.config || {};
    const chunking = cfg.chunking || {};
    const templateCfg = cfg.template || {};
    document.getElementById('inputPageThreshold').value = chunking.page_threshold || 10;
    document.getElementById('selectContextLevel').value = chunking.context_aware_level || 'h1';
    
    // Update Phase 2 document dropdown
    await loadPhase2Documents();
    
    // Update estimated chunk count
    await updateEstimatedChunkCount();
    const templateId = templateCfg.template_id || '';
    if (templateId) {
        templatesSelect.value = templateId;
    }
    refreshTemplatePreview(templateId);
    document.getElementById('selectTocLevel').value = templateCfg.toc_level || 'h2';
    document.getElementById('toggleLateAppend').checked = (templateCfg.late_append_relevancy_threshold ?? 0.45) >= 0;
    const llmCfg = cfg.llm || {};
    document.getElementById('inputLlmModel').value = llmCfg.model || 'claude-3-opus-20240229';
    document.getElementById('inputLlmTemperature').value = llmCfg.temperature ?? 0.2;
    const uiCfg = cfg.ui || {};
    document.getElementById('inputUiAppendHeading').value = uiCfg.append_unmapped_heading || 'Additional Sections';
    document.getElementById('toggleUiTitleHighlight').checked = uiCfg.show_ai_title_highlight !== false;
    document.getElementById('toggleUiComments').checked = uiCfg.show_ai_comments !== false;
    toggleConfigFieldsets(true);
    renderChunkPreview(state);
}

async function selectDocument(fileId) {
    const res = await fetch(`/api/doc_review/documents/${fileId}`);
    const data = await res.json();
    if (!data.document) return;
    activeDocumentId = fileId;
    activeDocument = data.document;
    renderOverview(activeDocument);
    renderMarkdown(activeDocument);
    renderLogs(activeDocument);
    renderChunkPreview(activeDocument);
    renderChatHistoryWithAttachments(activeDocument.state?.chat_history || []);
    populateConfigForm(activeDocument);
    await loadPhase1Summary(fileId);
    await loadPhase3Summary(fileId);
    highlightActiveDocument();
    setWorkflowTabsEnabled(true);
    subscribeToLogs(fileId);
    showTab('#tab-chunking');
}

async function loadPhase1Summary(fileId) {
    try {
        const res = await fetch(`/api/doc_review/documents/${fileId}/phase1_summary`);
        if (!res.ok) {
            document.getElementById('phase1SummaryRow').style.display = 'none';
            return;
        }
        const data = await res.json();
        const stats = data.phase1_stats || {};
        const report = data.phase1_report || {};
        
        // Render in overview panel (override Current Document Overview)
        renderPhase1Overview(stats, report, fileId);
        
        // Also render in Phase 1 Summary section in tab 1
        renderPhase1Summary(stats, report);
        document.getElementById('phase1SummaryRow').style.display = 'block';
    } catch (err) {
        console.error('Failed to load Phase 1 summary:', err);
        document.getElementById('phase1SummaryRow').style.display = 'none';
    }
}

async function loadPhase3Summary(fileId) {
    try {
        const res = await fetch(`/api/doc_review/documents/${fileId}`);
        if (!res.ok) {
            document.getElementById('phase3SummaryRow').style.display = 'none';
            return;
        }
        const data = await res.json();
        const state = data.document?.state || {};
        const stats = state.phase3_stats || {};
        const report = state.phase3_report || {};
        
        if (!stats || !Object.keys(stats).length) {
            document.getElementById('phase3SummaryRow').style.display = 'none';
            return;
        }
        
        renderPhase3Summary(stats, report);
        document.getElementById('phase3SummaryRow').style.display = 'block';
    } catch (err) {
        console.error('Failed to load Phase 3 summary:', err);
        document.getElementById('phase3SummaryRow').style.display = 'none';
    }
}

function renderPhase3Summary(stats, report) {
    const container = document.getElementById('phase3SummaryContent');
    if (!container) return;
    
    const statistics = stats.statistics || {};
    const ratios = stats.ratios || {};
    const status = stats.status || {};
    const analysis = report || {};
    
    // LLM Analysis Section (Top)
    let analysisHtml = '';
    if (analysis && Object.keys(analysis).length) {
        analysisHtml = `
            <div class="mb-4 p-3 border rounded" style="background-color: #F0F7FF; border-color: #003DA5;">
                <h6 class="mb-3" style="color: #003DA5;"><i class="bi bi-brain"></i> LLM Analysis</h6>
                ${analysis.summary ? `
                    <p class="mb-3" style="color: #0052A5;">${analysis.summary}</p>
                ` : ''}
                ${analysis.quality_score && analysis.quality_score !== 'unknown' ? `
                    <div class="mb-2">
                        <strong style="color: #003DA5;">Mapping Quality:</strong>
                        <span class="badge ms-2" style="background-color: #CCE5FF; color: #003DA5;">${analysis.quality_score}</span>
                    </div>
                ` : ''}
                ${analysis.insights && analysis.insights.length ? `
                    <div class="mb-2">
                        <strong style="color: #003DA5;">Key Insights:</strong>
                        <ul class="mb-0 mt-2">
                            ${analysis.insights.map(i => `<li style="color: #0052A5;">${i}</li>`).join('')}
                        </ul>
                    </div>
                ` : ''}
                ${analysis.recommendations && analysis.recommendations.length ? `
                    <div class="mb-2">
                        <strong style="color: #003DA5;">Recommendations:</strong>
                        <ul class="mb-0 mt-2">
                            ${analysis.recommendations.map(r => `<li style="color: #0052A5;">${r}</li>`).join('')}
                        </ul>
                    </div>
                ` : ''}
                ${analysis.anomalies && analysis.anomalies.length ? `
                    <div class="mb-0">
                        <strong style="color: #0066CC;">Anomalies:</strong>
                        <ul class="mb-0 mt-2">
                            ${analysis.anomalies.map(a => `<li style="color: #0066CC;">${a}</li>`).join('')}
                        </ul>
                    </div>
                ` : ''}
            </div>
        `;
    }
    
    // Statistics Section
    const statsHtml = `
        <div class="row g-3">
            <div class="col-md-6">
                <div class="border rounded p-3" style="background-color: #F8FAFC;">
                    <h6 class="mb-3" style="color: #003DA5;"><i class="bi bi-pie-chart"></i> Mapping Statistics</h6>
                    <div class="mb-2">
                        <strong>Total Sections:</strong> 
                        <span class="badge ms-2" style="background-color: #E6F2FF; color: #003DA5;">${statistics.total_sections || 0}</span>
                    </div>
                    <div class="mb-2">
                        <strong>Mapped:</strong> 
                        <span class="badge ms-2" style="background-color: #E6F2FF; color: #003DA5;">${statistics.mapped_sections || 0}</span>
                        <small class="text-muted">(${ratios.mapping_rate || 0}%)</small>
                    </div>
                    <div class="mb-2">
                        <strong>Unmapped:</strong> 
                        <span class="badge ms-2" style="background-color: #CCE5FF; color: #0052A5;">${statistics.unmapped_sections || 0}</span>
                        <small class="text-muted">(${ratios.unmapped_rate || 0}%)</small>
                    </div>
                    <div class="mb-2">
                        <strong>Late Appended:</strong> 
                        <span class="badge ms-2" style="background-color: #B3D9FF; color: #0066CC;">${statistics.appended_late_sections || 0}</span>
                        <small class="text-muted">(${ratios.late_append_rate || 0}%)</small>
                    </div>
                    <div class="mb-0">
                        <strong>Avg Confidence:</strong> 
                        <span class="badge ms-2" style="background-color: #E6F2FF; color: #003DA5;">${(statistics.mapping_confidence_avg || 0).toFixed(2)}</span>
                    </div>
                </div>
            </div>
            <div class="col-md-6">
                <div class="border rounded p-3" style="background-color: #F8FAFC;">
                    <h6 class="mb-3" style="color: #003DA5;"><i class="bi bi-pencil"></i> Improvements</h6>
                    <div class="mb-2">
                        <strong>Improved Titles:</strong> 
                        <span class="badge ms-2" style="background-color: #E6F2FF; color: #003DA5;">${statistics.improved_titles || 0}</span>
                        <small class="text-muted">(${ratios.title_improvement_rate || 0}%)</small>
                    </div>
                    ${statistics.categories && Object.keys(statistics.categories).length ? `
                        <div class="mb-0">
                            <strong>Relevancy Categories:</strong>
                            <div class="mt-2">
                                ${Object.entries(statistics.categories).map(([cat, count]) => `
                                    <span class="badge me-2 mb-1" style="background-color: #CCE5FF; color: #003DA5;">
                                        ${cat}: ${count}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            </div>
        </div>
        <div class="row g-3 mt-2">
            <div class="col-12">
                <div class="border rounded p-3" style="background-color: #F8FAFC;">
                    <h6 class="mb-3" style="color: #003DA5;"><i class="bi bi-check-circle"></i> Node Status</h6>
                    <div class="d-flex flex-wrap gap-3">
                        <div>
                            <strong>Heading Mapping:</strong> 
                            <span class="badge ms-2 ${status.heading_mapping_llm === 'pass' ? 'bg-success' : 'bg-secondary'}">${status.heading_mapping_llm || 'N/A'}</span>
                        </div>
                        <div>
                            <strong>Title Improver:</strong> 
                            <span class="badge ms-2 ${status.title_improver_llm === 'pass' ? 'bg-success' : status.title_improver_llm === 'skip' ? 'bg-warning' : 'bg-secondary'}">${status.title_improver_llm || 'N/A'}</span>
                        </div>
                        <div>
                            <strong>Relevancy Scoring:</strong> 
                            <span class="badge ms-2 ${status.relevancy_scoring_llm === 'pass' ? 'bg-success' : status.relevancy_scoring_llm === 'skip' ? 'bg-warning' : 'bg-secondary'}">${status.relevancy_scoring_llm || 'N/A'}</span>
                        </div>
                        <div>
                            <strong>Second Pass:</strong> 
                            <span class="badge ms-2 ${status.second_pass_mapping_llm === 'pass' ? 'bg-success' : status.second_pass_mapping_llm === 'skip' ? 'bg-warning' : 'bg-secondary'}">${status.second_pass_mapping_llm || 'N/A'}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    container.innerHTML = analysisHtml + statsHtml;
}


// Generate markdown formatted heading list with optional filter
function generateHeadingMarkdown(headingStructure, filterLevel = null) {
    if (!headingStructure || !headingStructure.length) {
        return 'No headings found.';
    }
    
    // Filter by level if specified
    let filteredHeadings = headingStructure;
    if (filterLevel && filterLevel !== 'all') {
        const targetLevel = filterLevel.toLowerCase();
        filteredHeadings = headingStructure.filter(h => {
            const level = (h.heading_level || 'h1').toLowerCase();
            return level === targetLevel;
        });
    }
    
    if (!filteredHeadings.length) {
        return `No ${filterLevel ? filterLevel.toUpperCase() + ' ' : ''}headings found.`;
    }
    
    let markdown = '';
    let prevLevel = 0;
    
    filteredHeadings.forEach((heading, index) => {
        const level = heading.heading_level || 'h1';
        const levelNum = parseInt(level.replace('h', '')) || 1;
        const text = heading.heading_text || '';
        const prefix = '#'.repeat(levelNum);
        
        // Add blank line between different heading levels for readability
        if (index > 0 && levelNum < prevLevel) {
            markdown += '\n';
        }
        
        markdown += `${prefix} ${text}\n`;
        prevLevel = levelNum;
    });
    
    return markdown.trim();
}

function renderPhase1Overview(stats, report, fileId) {
    if (!stats || !Object.keys(stats).length) {
        // If no Phase 1 stats, show fallback
        if (activeDocument) {
            renderOverviewFallback(activeDocument);
        }
        return;
    }
    
    const status = stats.status || {};
    const statistics = stats.statistics || {};
    const ratios = stats.ratios || {};
    const analysis = report?.analysis || {};
    const summary = report?.summary || '';
    const recommendations = report?.recommendations || [];
    const docStatus = activeDocument?.status || 'unknown';
    
    // Get document updated time
    const updatedAt = activeDocument?.updated_at || '';
    
    // Count pass/fail
    const statusEntries = Object.entries(status);
    const passedCount = statusEntries.filter(([_, v]) => v === 'pass').length;
    const failedCount = statusEntries.filter(([_, v]) => v === 'fail').length;
    
    const statusBadges = statusEntries.map(([tool, result]) => {
        const icon = result === 'pass' ? '‚úì' : '‚úó';
        const toolName = tool.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        const bgColor = result === 'pass' ? '#E6F2FF' : '#CCE5FF';
        const textColor = result === 'pass' ? '#003DA5' : '#0052A5';
        return `<span class="badge me-1" style="background-color: ${bgColor}; color: ${textColor};" title="${toolName}">${icon}</span>`;
    }).join('');
    
    overviewPanel.innerHTML = `
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h6 class="mb-0" style="color: #003DA5;">${fileId}</h6>
            ${statusPill(docStatus)}
        </div>
        
        <!-- Phase 1 Stats (Deterministic) -->
        <div class="mb-3">
            <h6 class="mb-2" style="color: #003DA5;"><i class="bi bi-bar-chart"></i> Phase 1 Statistics</h6>
            <div class="row g-2 mb-3">
                <div class="col-6 col-md-3">
                    <div class="card border-0" style="background-color: #E6F2FF; border-left: 3px solid #003DA5 !important;">
                        <div class="card-body p-3 text-center">
                            <div class="small" style="color: #0052A5;">Words</div>
                            <div class="fw-bold mt-1" style="color: #003DA5; font-size: 1.1rem;">${(statistics.word_count || 0).toLocaleString()}</div>
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="card border-0" style="background-color: #E6F2FF; border-left: 3px solid #003DA5 !important;">
                        <div class="card-body p-3 text-center">
                            <div class="small" style="color: #0052A5;">Pages</div>
                            <div class="fw-bold mt-1" style="color: #003DA5; font-size: 1.1rem;">${statistics.page_count || 0}</div>
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="card border-0" style="background-color: #E6F2FF; border-left: 3px solid #003DA5 !important;">
                        <div class="card-body p-3 text-center">
                            <div class="small" style="color: #0052A5;">Headings</div>
                            <div class="fw-bold mt-1" style="color: #003DA5; font-size: 1.1rem;">${statistics.total_headings || 0}</div>
                            ${statistics.heading_counts_by_level ? `
                                <div class="small mt-1" style="font-size: 0.7rem; color: #0066CC;">
                                    ${Object.entries(statistics.heading_counts_by_level)
                                        .filter(([_, count]) => count > 0)
                                        .map(([level, count]) => `${level.toUpperCase()}: ${count}`)
                                        .join(', ')}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                </div>
                <div class="col-6 col-md-3">
                    <div class="card border-0" style="background-color: #E6F2FF; border-left: 3px solid #003DA5 !important;">
                        <div class="card-body p-3 text-center">
                            <div class="small" style="color: #0052A5;">Images</div>
                            <div class="fw-bold mt-1" style="color: #003DA5; font-size: 1.1rem;">${statistics.total_images || 0}</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="row mb-3">
                <div class="col-md-6">
                    <div class="small" style="color: #003DA5;">
                        <strong>Tool Status:</strong> ${passedCount} passed, ${failedCount} failed<br>
                        ${statusBadges}
                    </div>
                </div>
                <div class="col-md-6">
                    <div class="small" style="color: #003DA5;">
                        <strong>Ratios:</strong><br>
                        Words/page: ${ratios.words_per_page || 0} | 
                        Images/page: ${ratios.images_per_page || 0} | 
                        Headings/page: ${ratios.headings_per_page || 0}
                    </div>
                </div>
            </div>
            
            <dl class="row small mb-0">
                <dt class="col-4" style="color: #0052A5;">File type</dt>
                <dd class="col-8" style="color: #003DA5;">${statistics.file_type || 'unknown'}</dd>
                <dt class="col-4" style="color: #0052A5;">Heading levels</dt>
                <dd class="col-8" style="color: #003DA5;">${(statistics.heading_levels || []).join(', ') || 'n/a'}</dd>
                <dt class="col-4" style="color: #0052A5;">Updated</dt>
                <dd class="col-8" style="color: #003DA5;">${updatedAt ? new Date(updatedAt).toLocaleString() : 'n/a'}</dd>
            </dl>
        </div>
        
        <!-- Heading Breakdown Section -->
        ${statistics.heading_structure && statistics.heading_structure.length ? `
            <div class="border-top pt-4 mt-4" style="border-color: #CCE5FF !important;">
                <h6 class="mb-3" style="color: #003DA5;"><i class="bi bi-list-nested"></i> Heading Breakdown</h6>
                
                <!-- Counts by Level -->
                <div class="mb-4">
                    <div class="row g-2">
                        ${['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].map(level => {
                            const count = (statistics.heading_counts_by_level && statistics.heading_counts_by_level[level]) || 0;
                            if (count === 0) return '';
                            return `
                                <div class="col-6 col-md-2">
                                    <div class="card border-0" style="background-color: #F0F7FF; border-left: 2px solid #0066CC !important;">
                                        <div class="card-body p-2 text-center">
                                            <div class="small" style="color: #0052A5;">${level.toUpperCase()}</div>
                                            <div class="fw-bold mt-1" style="color: #003DA5;">${count}</div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                
                <!-- Structured Markdown List -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0 small" style="color: #003DA5;"><i class="bi bi-file-text"></i> All Headings (Markdown Format)</h6>
                        <div class="btn-group btn-group-sm" role="group" aria-label="Heading filter">
                            <button type="button" class="btn btn-sm heading-filter-btn active" data-filter="all" style="background-color: #003DA5; color: white; border-color: #003DA5;">All</button>
                            ${['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].map(level => {
                                const count = (statistics.heading_counts_by_level && statistics.heading_counts_by_level[level]) || 0;
                                if (count === 0) return '';
                                return `<button type="button" class="btn btn-sm heading-filter-btn" data-filter="${level}" style="background-color: #E6F2FF; color: #003DA5; border-color: #CCE5FF;">${level.toUpperCase()}</button>`;
                            }).join('')}
                        </div>
                    </div>
                    <div class="card border-0" style="background-color: #F9FBFF; border: 1px solid #CCE5FF;">
                        <div class="card-body p-3" style="max-height: 400px; overflow-y: auto;">
                            <pre class="mb-0 small heading-markdown-display" style="white-space: pre-wrap; font-family: 'Courier New', monospace; color: #003DA5;" data-headings='${JSON.stringify(statistics.heading_structure)}'>${generateHeadingMarkdown(statistics.heading_structure)}</pre>
                        </div>
                    </div>
                </div>
            </div>
        ` : ''}
        
        <!-- LLM Analysis Section (Last) -->
        ${analysis && Object.keys(analysis).length && summary ? `
            <div class="border-top pt-4 mt-4" style="border-color: #CCE5FF !important;">
                <h6 class="mb-3" style="color: #003DA5;"><i class="bi bi-brain"></i> LLM Analysis</h6>
                <div class="p-3 mb-3" style="background-color: #E6F2FF; border-left: 3px solid #0052A5; border-radius: 0.25rem;">
                    <strong style="color: #003DA5;">Summary:</strong>
                    <p class="mb-0 mt-2 small" style="color: #0052A5;">${summary}</p>
                </div>
                ${analysis.quality_score && analysis.quality_score !== 'unknown' ? `
                    <div class="mb-3">
                        <strong style="color: #003DA5;">Quality Score:</strong>
                        <span class="badge ms-2" style="background-color: #CCE5FF; color: #003DA5;">${analysis.quality_score}</span>
                    </div>
                ` : ''}
                ${analysis.insights && analysis.insights.length ? `
                    <div class="mb-3">
                        <strong style="color: #003DA5;">Insights:</strong>
                        <ul class="mb-0 mt-2 small" style="color: #0052A5;">
                            ${analysis.insights.map(i => `<li>${i}</li>`).join('')}
                        </ul>
                    </div>
                ` : ''}
                ${analysis.anomalies && analysis.anomalies.length ? `
                    <div class="p-3 mb-3" style="background-color: #F0F7FF; border-left: 3px solid #0066CC; border-radius: 0.25rem;">
                        <strong style="color: #0066CC;">‚ö†Ô∏è Anomalies Detected:</strong>
                        <ul class="mb-0 mt-2 small" style="color: #0052A5;">
                            ${analysis.anomalies.map(a => `<li>${a}</li>`).join('')}
                        </ul>
                    </div>
                ` : ''}
                ${recommendations && recommendations.length ? `
                    <div class="mb-3">
                        <strong style="color: #003DA5;">Recommendations:</strong>
                        <ul class="mb-0 mt-2 small" style="color: #0052A5;">
                            ${recommendations.map(r => `<li>${r}</li>`).join('')}
                        </ul>
                    </div>
                ` : ''}
                
                <!-- Proceed to Phase 2 Button -->
                <div class="mt-4 pt-3" style="border-top: 1px solid #CCE5FF;">
                    <button type="button" class="btn w-100" id="btnProceedPhase2" style="background-color: #003DA5; color: white; border: none; padding: 0.75rem; font-weight: 500;">
                        <i class="bi bi-arrow-right-circle"></i> Proceed to Phase 2
                    </button>
                    <div class="form-text mt-2 small" style="color: #0066CC; text-align: center;">
                        Phase 2: Chunking & Index Building
                    </div>
                </div>
            </div>
        ` : ''}
    `;
}

function renderPhase1Summary(stats, report) {
    const container = document.getElementById('phase1SummaryContent');
    if (!stats || !Object.keys(stats).length) {
        container.innerHTML = '<div class="text-center text-muted"><p>Phase 1 not yet completed. Run the workflow to generate summary.</p></div>';
        return;
    }
    
    const status = stats.status || {};
    const statistics = stats.statistics || {};
    const ratios = stats.ratios || {};
    const analysis = report?.analysis || {};
    const recommendations = report?.recommendations || [];
    const summary = report?.summary || '';
    
    const statusBadges = Object.entries(status).map(([tool, result]) => {
        const icon = result === 'pass' ? '‚úì' : '‚úó';
        const bgColor = result === 'pass' ? '#E6F2FF' : '#CCE5FF';
        const textColor = result === 'pass' ? '#003DA5' : '#0052A5';
        return `<span class="badge me-1" style="background-color: ${bgColor}; color: ${textColor};">${icon} ${tool.replace(/_/g, ' ')}</span>`;
    }).join('');
    
    const statsHtml = `
        <div class="row mb-3">
            <div class="col-md-3">
                <div class="card border-0" style="background-color: #E6F2FF; border-left: 3px solid #003DA5 !important;">
                    <div class="card-body text-center p-3">
                        <h6 class="mb-1" style="color: #0052A5;">Word Count</h6>
                        <h4 class="mb-0" style="color: #003DA5;">${(statistics.word_count || 0).toLocaleString()}</h4>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card border-0" style="background-color: #E6F2FF; border-left: 3px solid #003DA5 !important;">
                    <div class="card-body text-center p-3">
                        <h6 class="mb-1" style="color: #0052A5;">Pages</h6>
                        <h4 class="mb-0" style="color: #003DA5;">${statistics.page_count || 0}</h4>
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card border-0" style="background-color: #E6F2FF; border-left: 3px solid #003DA5 !important;">
                    <div class="card-body text-center p-3">
                        <h6 class="mb-1" style="color: #0052A5;">Headings</h6>
                        <h4 class="mb-0" style="color: #003DA5;">${statistics.total_headings || 0}</h4>
                        ${statistics.heading_counts_by_level ? `
                            <div class="small mt-1" style="font-size: 0.75rem; color: #0066CC;">
                                ${Object.entries(statistics.heading_counts_by_level)
                                    .filter(([_, count]) => count > 0)
                                    .map(([level, count]) => `${level.toUpperCase()}: ${count}`)
                                    .join(', ')}
                            </div>
                        ` : ''}
                    </div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="card border-0" style="background-color: #E6F2FF; border-left: 3px solid #003DA5 !important;">
                    <div class="card-body text-center p-3">
                        <h6 class="mb-1" style="color: #0052A5;">Images</h6>
                        <h4 class="mb-0" style="color: #003DA5;">${statistics.total_images || 0}</h4>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="row mb-3">
            <div class="col-md-6">
                <h6 style="color: #003DA5;"><i class="bi bi-check-circle"></i> Tool Status</h6>
                <div class="mb-2">${statusBadges}</div>
            </div>
            <div class="col-md-6">
                <h6 style="color: #003DA5;"><i class="bi bi-graph-up-arrow"></i> Ratios</h6>
                <ul class="list-unstyled mb-0" style="color: #003DA5;">
                    <li><strong>Words/page:</strong> ${ratios.words_per_page || 0}</li>
                    <li><strong>Images/page:</strong> ${ratios.images_per_page || 0}</li>
                    <li><strong>Headings/page:</strong> ${ratios.headings_per_page || 0}</li>
                </ul>
            </div>
        </div>
    `;
    
    // Heading Breakdown Section
    let headingBreakdownHtml = '';
    if (statistics.heading_structure && statistics.heading_structure.length) {
        const headingCounts = statistics.heading_counts_by_level || {};
        headingBreakdownHtml = `
            <div class="border-top pt-4 mt-4" style="border-color: #CCE5FF !important;">
                <h6 class="mb-3" style="color: #003DA5;"><i class="bi bi-list-nested"></i> Heading Breakdown</h6>
                
                <!-- Counts by Level -->
                <div class="mb-4">
                    <div class="row g-2">
                        ${['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].map(level => {
                            const count = headingCounts[level] || 0;
                            if (count === 0) return '';
                            return `
                                <div class="col-6 col-md-2">
                                    <div class="card border-0" style="background-color: #F0F7FF; border-left: 2px solid #0066CC !important;">
                                        <div class="card-body p-2 text-center">
                                            <div class="small" style="color: #0052A5;">${level.toUpperCase()}</div>
                                            <div class="fw-bold mt-1" style="color: #003DA5;">${count}</div>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
                
                <!-- Structured Markdown List -->
                <div class="mb-3">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <h6 class="mb-0 small" style="color: #003DA5;"><i class="bi bi-file-text"></i> All Headings (Markdown Format)</h6>
                        <div class="btn-group btn-group-sm" role="group" aria-label="Heading filter">
                            <button type="button" class="btn btn-sm heading-filter-btn active" data-filter="all" style="background-color: #003DA5; color: white; border-color: #003DA5;">All</button>
                            ${['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].map(level => {
                                const headingCounts = statistics.heading_counts_by_level || {};
                                const count = headingCounts[level] || 0;
                                if (count === 0) return '';
                                return `<button type="button" class="btn btn-sm heading-filter-btn" data-filter="${level}" style="background-color: #E6F2FF; color: #003DA5; border-color: #CCE5FF;">${level.toUpperCase()}</button>`;
                            }).join('')}
                        </div>
                    </div>
                    <div class="card border-0" style="background-color: #F9FBFF; border: 1px solid #CCE5FF;">
                        <div class="card-body p-3" style="max-height: 400px; overflow-y: auto;">
                            <pre class="mb-0 small heading-markdown-display" style="white-space: pre-wrap; font-family: 'Courier New', monospace; color: #003DA5;" data-headings='${JSON.stringify(statistics.heading_structure)}'>${generateHeadingMarkdown(statistics.heading_structure)}</pre>
                        </div>
                    </div>
                </div>
            </div>
        `;
    }
    
    // LLM Analysis Section (Last)
    let llmAnalysisHtml = '';
    if (analysis && Object.keys(analysis).length && summary) {
        llmAnalysisHtml = `
            <div class="border-top pt-4 mt-4" style="border-color: #CCE5FF !important;">
                <h6 class="mb-3" style="color: #003DA5;"><i class="bi bi-brain"></i> LLM Analysis</h6>
                <div class="p-3 mb-3" style="background-color: #E6F2FF; border-left: 3px solid #0052A5; border-radius: 0.25rem;">
                    <strong style="color: #003DA5;">Summary:</strong>
                    <p class="mb-0 mt-2 small" style="color: #0052A5;">${summary}</p>
                </div>
                ${analysis.quality_score && analysis.quality_score !== 'unknown' ? `
                    <div class="mb-3">
                        <strong style="color: #003DA5;">Quality Score:</strong>
                        <span class="badge ms-2" style="background-color: #CCE5FF; color: #003DA5;">${analysis.quality_score}</span>
                    </div>
                ` : ''}
                ${analysis.insights && analysis.insights.length ? `
                    <div class="mb-3">
                        <strong style="color: #003DA5;">Insights:</strong>
                        <ul class="mb-0 mt-2 small" style="color: #0052A5;">
                            ${analysis.insights.map(i => `<li>${i}</li>`).join('')}
                        </ul>
                    </div>
                ` : ''}
                ${analysis.anomalies && analysis.anomalies.length ? `
                    <div class="p-3 mb-3" style="background-color: #F0F7FF; border-left: 3px solid #0066CC; border-radius: 0.25rem;">
                        <strong style="color: #0066CC;">‚ö†Ô∏è Anomalies Detected:</strong>
                        <ul class="mb-0 mt-2 small" style="color: #0052A5;">
                            ${analysis.anomalies.map(a => `<li>${a}</li>`).join('')}
                        </ul>
                    </div>
                ` : ''}
                ${recommendations && recommendations.length ? `
                    <div class="mb-3">
                        <strong style="color: #003DA5;">Recommendations:</strong>
                        <ul class="mb-0 mt-2 small" style="color: #0052A5;">
                            ${recommendations.map(r => `<li>${r}</li>`).join('')}
                        </ul>
                    </div>
                ` : ''}
                
                <!-- Proceed to Phase 2 Button -->
                <div class="mt-4 pt-3" style="border-top: 1px solid #CCE5FF;">
                    <button type="button" class="btn w-100" id="btnProceedPhase2" style="background-color: #003DA5; color: white; border: none; padding: 0.75rem; font-weight: 500;">
                        <i class="bi bi-arrow-right-circle"></i> Proceed to Phase 2
                    </button>
                    <div class="form-text mt-2 small" style="color: #0066CC; text-align: center;">
                        Phase 2: Chunking & Index Building
                    </div>
                </div>
            </div>
        `;
    }
    
    container.innerHTML = statsHtml + headingBreakdownHtml + llmAnalysisHtml;
}

function collectConfigOverrides() {
    return {
        chunking: {
            page_threshold: Number(document.getElementById('inputPageThreshold').value || 10),
            context_aware_level: document.getElementById('selectContextLevel').value,
        },
        template: {
            template_id: templatesSelect.value || null,
            toc_level: document.getElementById('selectTocLevel').value,
            late_append_relevancy_threshold: document.getElementById('toggleLateAppend').checked ? 0.45 : -1,
        },
        llm: {
            model: document.getElementById('inputLlmModel').value || null,
            temperature: Number(document.getElementById('inputLlmTemperature').value || 0.2),
        },
        ui: {
            append_unmapped_heading: document.getElementById('inputUiAppendHeading').value || null,
            show_ai_title_highlight: document.getElementById('toggleUiTitleHighlight').checked,
            show_ai_comments: document.getElementById('toggleUiComments').checked,
        },
    };
}

// Calculate estimated chunk count based on document and settings
async function calculateEstimatedChunkCount(fileId) {
    if (!fileId) return 0;
    
    try {
        // Load Phase 1 summary to get heading structure
        const res = await fetch(`/api/doc_review/documents/${fileId}/phase1_summary`);
        if (!res.ok) return 0;
        
        const data = await res.json();
        const stats = data.phase1_stats || {};
        const headingStructure = stats.heading_structure || [];
        const pageCount = stats.page_count || 0;
        
        // Get current settings
        const pageThreshold = Number(document.getElementById('inputPageThreshold').value || 10);
        const contextLevel = document.getElementById('selectContextLevel').value;
        
        // Check if chunking will be enabled
        if (pageCount < pageThreshold) {
            return 1; // Single chunk if below threshold
        }
        
        // Count headings at the target level
        const targetLevel = contextLevel.toLowerCase();
        const matchingHeadings = headingStructure.filter(h => 
            (h.heading_level || '').toLowerCase() === targetLevel
        );
        
        return matchingHeadings.length || 1;
    } catch (err) {
        console.error('Failed to calculate estimated chunks:', err);
        return 0;
    }
}

// Update estimated chunk count display
async function updateEstimatedChunkCount() {
    const fileId = selectDocumentPhase2?.value || activeDocumentId;
    if (!fileId) {
        estimatedChunksInput.value = '';
        return;
    }
    
    const count = await calculateEstimatedChunkCount(fileId);
    estimatedChunksInput.value = count > 0 ? `${count} chunks` : 'N/A';
}

// Load documents for Phase 4 dropdown (documents that have Phase 2 completed)
async function loadPhase4Documents() {
    if (!selectDocumentPhase4) return;
    
    try {
        const res = await fetch('/api/doc_review/documents');
        const data = await res.json();
        
        selectDocumentPhase4.innerHTML = '<option value="">-- Select a document --</option>';
        
        if (Array.isArray(data.documents)) {
            // Filter documents that have Phase 2 completed (have chunks and index)
            const phase2Completed = data.documents.filter(doc => {
                const state = doc.state || {};
                return state.chunks && state.chunks.length > 0 && 
                       state.index && state.index.sections;
            });
            
            if (phase2Completed.length === 0) {
                selectDocumentPhase4.innerHTML += '<option value="" disabled>No documents with Phase 2 completed</option>';
                return;
            }
            
            phase2Completed.forEach(doc => {
                const option = document.createElement('option');
                option.value = doc.file_id;
                option.textContent = doc.file_metadata?.file_id || doc.file_id || 'Unknown Document';
                selectDocumentPhase4.appendChild(option);
            });
        }
    } catch (err) {
        console.error('Failed to load Phase 4 documents:', err);
        selectDocumentPhase4.innerHTML = '<option value="">Error loading documents</option>';
    }
}

// Handle Phase 4 document selection
async function handlePhase4DocumentSelect() {
    const selectedFileId = selectDocumentPhase4?.value;
    if (!selectedFileId) {
        btnRunPhase4.disabled = true;
        activeDocumentId = null;
        activeDocument = null;
        if (markdownEditor) {
            markdownEditor.value = '';
            markdownEditor.disabled = true;
        }
        if (chatHistory) {
            chatHistory.innerHTML = '<em>No interactions yet.</em>';
        }
        return;
    }
    
    try {
        // Set active document ID for chat functionality
        activeDocumentId = selectedFileId;
        
        // Load document state
        const res = await fetch(`/api/doc_review/documents/${selectedFileId}`);
        if (!res.ok) throw new Error('Failed to load document');
        
        const data = await res.json();
        const doc = data.document || {};
        activeDocument = doc;
        const state = doc.state || {};
        
        // Enable Run Phase 4 button if document has Phase 2 data
        const hasPhase2Data = state.chunks && state.chunks.length > 0 && 
                              state.index && state.index.sections;
        btnRunPhase4.disabled = !hasPhase2Data;
        
        // If improved markdown already exists, load it
        if (state.improved_markdown && markdownEditor) {
            markdownEditor.value = state.improved_markdown;
            markdownEditor.disabled = false;
        } else if (markdownEditor) {
            markdownEditor.value = '';
            markdownEditor.disabled = true;
        }
        
        // Load TOC if available
        if (state.toc_markdown && tocPreview) {
            tocPreview.innerHTML = `<div class="border rounded p-3 bg-light"><h6>Table of Contents</h6><pre class="mb-0" style="white-space: pre-wrap; word-wrap: break-word;">${state.toc_markdown}</pre></div>`;
        } else if (tocPreview) {
            tocPreview.innerHTML = '';
        }
        
        // Load chat history if available
        if (state.chat_history && chatHistory) {
            renderChatHistoryWithAttachments(state.chat_history);
        } else if (chatHistory) {
            chatHistory.innerHTML = '<em>No interactions yet.</em>';
        }
        
    } catch (err) {
        console.error('Failed to load Phase 4 document:', err);
        btnRunPhase4.disabled = true;
        activeDocumentId = null;
        activeDocument = null;
    }
}

// Run Phase 4 workflow
async function runPhase4Workflow() {
    const selectedFileId = selectDocumentPhase4?.value;
    if (!selectedFileId) {
        alert('Please select a document first.');
        return;
    }
    
    if (!btnRunPhase4) return;
    btnRunPhase4.disabled = true;
    btnRunPhase4.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Running Phase 4...';
    
    try {
        const res = await fetch(`/api/doc_review/documents/${selectedFileId}/run_phase4`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
        });
        
        if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error || res.statusText);
        }
        
        const data = await res.json();
        
        // Reload document to get updated state
        const docRes = await fetch(`/api/doc_review/documents/${selectedFileId}`);
        if (docRes.ok) {
            const docData = await docRes.json();
            const state = docData.document?.state || {};
            
            // Update active document
            activeDocumentId = selectedFileId;
            activeDocument = docData.document;
            
            // Update improved markdown display
            if (state.improved_markdown && markdownEditor) {
                markdownEditor.value = state.improved_markdown;
                markdownEditor.disabled = false;
            } else if (markdownEditor) {
                markdownEditor.value = '';
                markdownEditor.disabled = true;
            }
            
            // Update TOC display
            if (state.toc_markdown && tocPreview) {
                tocPreview.innerHTML = `<div class="border rounded p-3 bg-light"><h6>Table of Contents</h6><pre class="mb-0" style="white-space: pre-wrap; word-wrap: break-word;">${state.toc_markdown}</pre></div>`;
            } else if (tocPreview) {
                tocPreview.innerHTML = '';
            }
            
            // Reload chat history if available
            if (state.chat_history && chatHistory) {
                renderChatHistoryWithAttachments(state.chat_history);
            } else if (chatHistory) {
                chatHistory.innerHTML = '<em>No interactions yet.</em>';
            }
        }
        
        btnRunPhase4.innerHTML = '<i class="bi bi-check-circle"></i> Phase 4 Complete';
        setTimeout(() => {
            btnRunPhase4.innerHTML = '<i class="bi bi-play-circle"></i> Run Phase 4';
            btnRunPhase4.disabled = false;
        }, 3000);
        
    } catch (err) {
        console.error('Phase 4 workflow failed:', err);
        alert(err.message || 'Phase 4 workflow failed');
        btnRunPhase4.innerHTML = '<i class="bi bi-play-circle"></i> Run Phase 4';
        btnRunPhase4.disabled = false;
    }
}

// Check Phase 4 availability and enable tab
async function checkPhase4Availability() {
    try {
        const res = await fetch('/api/doc_review/documents');
        const data = await res.json();
        
        if (Array.isArray(data.documents)) {
            const phase2Completed = data.documents.filter(doc => {
                const state = doc.state || {};
                return state.chunks && state.chunks.length > 0 && 
                       state.index && state.index.sections;
            });
            
            if (phase2Completed.length > 0) {
                const tabButton = document.getElementById('tabButtonReview');
                if (tabButton) {
                    tabButton.disabled = false;
                    tabButton.classList.remove('disabled');
                }
                // Load documents into dropdown
                await loadPhase4Documents();
            }
        }
    } catch (err) {
        console.error('Failed to check Phase 4 availability:', err);
    }
}

// Handle Phase 4 tab click
function handlePhase4TabClick() {
    loadPhase4Documents();
}

// Load documents for Phase 2 dropdown (documents that have Phase 1 completed)
async function loadPhase2Documents() {
    if (!selectDocumentPhase2) return;
    
    try {
        const res = await fetch('/api/doc_review/documents');
        const data = await res.json();
        
        selectDocumentPhase2.innerHTML = '<option value="">-- Select a document --</option>';
        
        if (Array.isArray(data.documents)) {
            // Filter documents that have Phase 1 completed (have phase1_stats or phase1_report)
            const phase1Completed = data.documents.filter(doc => {
                const state = doc.state || {};
                return state.phase1_stats || state.phase1_report || 
                       (state.file_metadata && state.file_metadata.page_count);
            });
            
            if (phase1Completed.length === 0) {
                // No documents with Phase 1, add placeholder
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = '-- No documents with Phase 1 completed --';
                placeholder.disabled = true;
                selectDocumentPhase2.appendChild(placeholder);
                return;
            }
            
            phase1Completed.forEach(doc => {
                const option = document.createElement('option');
                option.value = doc.file_id;
                const pageCount = doc.state?.file_metadata?.page_count || doc.file_metadata?.page_count || 0;
                option.textContent = `${doc.file_id} (${pageCount} pages)`;
                if (doc.file_id === activeDocumentId) {
                    option.selected = true;
                }
                selectDocumentPhase2.appendChild(option);
            });
            
            // Default to active document if it has Phase 1 data
            if (activeDocumentId && activeDocument) {
                const state = activeDocument.state || {};
                const hasPhase1 = state.phase1_stats || state.phase1_report || 
                                (state.file_metadata && state.file_metadata.page_count);
                if (hasPhase1 && !selectDocumentPhase2.value) {
                    selectDocumentPhase2.value = activeDocumentId;
                }
            }
            
            // Update estimated count if document is selected
            if (selectDocumentPhase2.value) {
                await updateEstimatedChunkCount();
            }
        }
    } catch (err) {
        console.error('Failed to load Phase 2 documents:', err);
    }
}

async function patchConfig() {
    console.log('patchConfig: Called');
    // Get selected document from Phase 2 dropdown or use active document
    const selectedFileId = selectDocumentPhase2?.value || activeDocumentId;
    console.log('patchConfig: Selected file ID:', selectedFileId);
    if (!selectedFileId) {
        alert('Please select a document first');
        return;
    }
    
    // If switching document, update active document
    if (selectedFileId !== activeDocumentId) {
        await selectDocument(selectedFileId);
    }
    
    // Calculate and display estimated chunk count
    await updateEstimatedChunkCount();
    
    // Clear previous Phase 2 results if running on same document
    // Note: The backend will overwrite these when running, but we clear locally for immediate UI feedback
    if (activeDocument?.state?.chunks || activeDocument?.state?.index) {
        // Clear Phase 2 state locally (backend will overwrite with new results)
        if (activeDocument.state) {
            delete activeDocument.state.chunks;
            delete activeDocument.state.index;
            delete activeDocument.state.chunking_decision;
            // Also clear Phase 3+ results that depend on Phase 2
            delete activeDocument.state.template;
            delete activeDocument.state.improved_markdown;
            delete activeDocument.state.ui_annotations;
        }
        // Update UI to show cleared state
        renderChunkPreview(activeDocument);
    }
    
    const overrides = collectConfigOverrides();
    subscribeToLogs(selectedFileId);
    
    if (applyBtn) {
        applyBtn.disabled = true;
        applyBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Processing...';
    }
    
    try {
        console.log('Phase 2: Starting chunking for document:', selectedFileId);
        console.log('Phase 2: Config overrides:', overrides);
        
        // Run Phase 2 workflow (chunking & indexing) only
        const res = await fetch(`/api/doc_review/documents/${selectedFileId}/run_phase2`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ config: overrides })
        });
        
        console.log('Phase 2: Response status:', res.status);
        
        if (!res.ok) {
            const err = await res.json().catch(() => ({ error: res.statusText }));
            console.error('Phase 2: Error response:', err);
            throw new Error(err.error || res.statusText);
        }
        
        const data = await res.json();
        console.log('Phase 2: Response data:', data);
        activeDocument = data.document;
        activeDocumentId = selectedFileId;
        
        console.log('Phase 2: Active document chunks:', activeDocument?.state?.chunks?.length || 0);
        console.log('Phase 2: Active document index:', activeDocument?.state?.index ? 'exists' : 'missing');
        
        renderOverview(activeDocument);
        renderMarkdown(activeDocument);
        renderLogs(activeDocument);
        renderChunkPreview(activeDocument);
        populateConfigForm(activeDocument);
        await loadDocuments();
        await loadPhase2Documents();
        await updateEstimatedChunkCount();
        
        console.log('Phase 2: Completed successfully');
    } catch (err) {
        console.error('Phase 2: Exception:', err);
        alert(`Phase 2 chunking failed: ${err.message}`);
    } finally {
        if (applyBtn) {
            applyBtn.disabled = false;
            applyBtn.innerHTML = '<i class="bi bi-arrow-repeat"></i> Apply Chunking';
        }
    }
}

async function runWorkflow(evt) {
    if (evt) {
        evt.preventDefault();
        evt.stopPropagation();
    }
    if (!activeDocumentId) {
        alert('Please select a document first');
        return;
    }
    
    const runBtn = document.getElementById('btn-run');
    if (runBtn) {
        runBtn.disabled = true;
        runBtn.innerHTML = '<i class="bi bi-hourglass-split"></i> Running...';
    }
    
    subscribeToLogs(activeDocumentId);
    markdownEditor.disabled = true;
    saveMarkdownButton.disabled = true;
    markdownDirty = false;
    showTab('#tab-analysis');
    // Listen for raw markdown readiness to populate editor as soon as Phase 0 completes
    try {
        if (window.socket) {
            window.socket.on('doc_review:markdown_ready', async (msg) => {
                if (!msg || msg.file_id !== activeDocumentId) return;
                try {
                    const vfs = await fetch(`/api/doc_review/vfs/file?file_id=${encodeURIComponent(activeDocumentId)}&path=${encodeURIComponent(msg.path || '/raw.md')}`);
                    if (vfs.ok) {
                        const v = await vfs.json();
                        renderMarkdown({ state: { raw_markdown: v.content } });
                    }
                } catch (e) {
                    console.warn('Failed to fetch raw.md after markdown_ready:', e);
                }
            });
        }
    } catch (e) {
        console.warn('Unable to attach markdown_ready handler:', e);
    }
    const overrides = collectConfigOverrides();
    try {
        const res = await fetch(`/api/doc_review/documents/${activeDocumentId}/run`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ config: overrides })
        });
        if (!res.ok) {
            const err = await res.json().catch(() => ({ error: res.statusText }));
            throw new Error(err.error || res.statusText);
        }
        const data = await res.json();
        activeDocument = data.document;
        renderOverview(activeDocument);
        renderMarkdown(activeDocument);
        renderLogs(activeDocument);
        renderChunkPreview(activeDocument);
        await loadPhase1Summary(activeDocumentId);
        await loadPhase3Summary(activeDocumentId);
        await loadDocuments();
        setWorkflowTabsEnabled(true);
        showTab('#tab-analysis'); // Stay on analysis tab to see Phase 3 results
        markdownEditor.disabled = !activeDocument.state?.improved_markdown;
    } catch (err) {
        console.error('Workflow failed:', err);
        alert(`Workflow failed: ${err.message}\n\nCheck console for details.`);
        if (runBtn) {
            runBtn.disabled = false;
            runBtn.innerHTML = '<i class="bi bi-play-fill"></i> Phase 3 Submit';
        }
    } finally {
        if (runBtn && !runBtn.disabled) {
            runBtn.innerHTML = '<i class="bi bi-play-fill"></i> Phase 3 Submit';
        }
    }
}

async function saveMarkdown() {
    if (!activeDocumentId) return;
    const markdown = markdownEditor.value;
    try {
        const res = await fetch(`/api/doc_review/documents/${activeDocumentId}/markdown`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ markdown })
        });
        if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error || res.statusText);
        }
        const data = await res.json();
        activeDocument = data.document;
        renderMarkdown(activeDocument);
        renderLogs(activeDocument);
        await loadDocuments();
        showTab('#tab-review');
    } catch (err) {
        alert(`Failed to save markdown: ${err.message}`);
    }
}

// Load upload directory location and files
async function loadUploadDirFiles() {
    try {
        const res = await fetch('/api/doc_review/upload_dir/files');
        if (!res.ok) return;
        const data = await res.json();
        if (uploadLocationDisplay) {
            uploadLocationDisplay.textContent = data.upload_dir;
        }
        
        // Populate dropdown
        if (selectDocumentDropdown) {
            selectDocumentDropdown.innerHTML = '<option value="">-- Select a document --</option>';
            data.files.forEach(file => {
                const option = document.createElement('option');
                option.value = file.path;
                option.textContent = file.filename;
                option.dataset.filePath = file.path;
                selectDocumentDropdown.appendChild(option);
            });
        }
    } catch (err) {
        console.error('Failed to load upload directory files:', err);
    }
}

// Handle document selection from dropdown
async function handleDocumentSelect() {
    const selectedPath = selectDocumentDropdown?.value;
    if (!selectedPath) {
        if (btnRunPhase1) btnRunPhase1.disabled = true;
        return;
    }
    
    // Extract file_id from filename (use stem without unique prefix)
    const filename = selectDocumentDropdown.options[selectDocumentDropdown.selectedIndex].textContent;
    // Remove UUID prefix and extension to get clean file_id
    const fileStem = filename.replace(/^[a-f0-9]{32}_/, '').replace(/\.[^.]+$/, '');
    const fileId = fileStem || filename.replace(/\.[^.]+$/, '');
    
    // Check if document already exists in store
    try {
        const res = await fetch(`/api/doc_review/documents/${fileId}`);
        if (res.ok) {
            // Document exists, load it
            const data = await res.json();
            activeDocumentId = fileId;
            activeDocument = data.document;
            renderOverview(activeDocument);
            await loadPhase1Summary(activeDocumentId);
        } else {
            // Document doesn't exist, create it
            await createDocumentFromPath(fileId, selectedPath);
        }

        // Auto-run Phase 1 if raw markdown is not present yet
        const hasRaw = !!(activeDocument?.state && activeDocument.state.raw_markdown);
        if (!hasRaw && activeDocumentId) {
            subscribeToLogs(activeDocumentId);
            try {
                const runRes = await fetch(`/api/doc_review/documents/${activeDocumentId}/run_phase1`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const runData = await runRes.json();
                if (runRes.ok && runData.document) {
                    activeDocument = runData.document;
                }
            } catch (e) {
                console.error('Auto Phase 1 failed:', e);
            }
        }

        // Render raw markdown into middle panel if available
        if (activeDocument?.state?.raw_markdown) {
            renderMarkdown(activeDocument);
        } else if (activeDocumentId) {
            // Attempt to fetch from VFS if markdown_ready will be emitted
            try {
                const vfsRes = await fetch(`/api/doc_review/vfs/file?file_id=${encodeURIComponent(activeDocumentId)}&path=${encodeURIComponent('/raw.md')}`);
                if (vfsRes.ok) {
                    const v = await vfsRes.json();
                    renderMarkdown({ state: { raw_markdown: v.content } });
                }
            } catch (e) {
                // no-op; will populate on websocket event
            }
        }

        if (btnRunPhase1) btnRunPhase1.disabled = false;
    } catch (err) {
        console.error('Failed to check/create document:', err);
        alert(`Error: ${err.message}`);
    }
}

// Create document record from file path
async function createDocumentFromPath(fileId, filePath) {
    try {
        const res = await fetch('/api/doc_review/documents', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                file_id: fileId,
                source_path: filePath,
            })
        });
        if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error || res.statusText);
        }
        const data = await res.json();
        activeDocumentId = fileId;
        activeDocument = data.document;
        renderOverview(activeDocument);
        await loadDocuments();
    } catch (err) {
        console.error('Failed to create document:', err);
        throw err;
    }
}

// Run Phase 1 only
async function runPhase1Workflow() {
    if (!activeDocumentId) {
        alert('Please select a document first');
        return;
    }
    
    if (!confirm('Start Phase 1 processing? This will run ingestion and normalization tools.')) {
        return;
    }
    
    if (btnRunPhase1) {
        btnRunPhase1.disabled = true;
        btnRunPhase1.innerHTML = '<i class="bi bi-hourglass-split"></i> Processing...';
    }
    subscribeToLogs(activeDocumentId);
    
    try {
        const res = await fetch(`/api/doc_review/documents/${activeDocumentId}/run_phase1`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({})
        });
        if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error || res.statusText);
        }
        const data = await res.json();
        activeDocument = data.document;
        renderOverview(activeDocument);
        renderLogs(activeDocument);
        await loadPhase1Summary(activeDocumentId);
        await loadPhase3Summary(activeDocumentId);
        await loadDocuments();
        if (btnRunPhase1) {
            btnRunPhase1.innerHTML = '<i class="bi bi-check-circle"></i> Phase 1 Complete';
            setTimeout(() => {
                btnRunPhase1.innerHTML = '<i class="bi bi-play-circle"></i> Start Phase 1 Processing';
                btnRunPhase1.disabled = false;
            }, 3000);
        }
    } catch (err) {
        alert(`Phase 1 failed: ${err.message}`);
        if (btnRunPhase1) {
            btnRunPhase1.innerHTML = '<i class="bi bi-play-circle"></i> Start Phase 1 Processing';
            btnRunPhase1.disabled = false;
        }
    }
}

async function ingestDocument(evt) {
    evt.preventDefault();
    const sourcePath = document.getElementById('inputSourcePath').value.trim();
    const fileId = document.getElementById('inputFileId').value.trim();
    if (!sourcePath) {
        alert('Provide a source path');
        return;
    }
    const payload = { source_path: sourcePath };
    if (fileId) payload.file_id = fileId;
    try {
        const res = await fetch('/api/doc_review/documents', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error || res.statusText);
        }
        const data = await res.json();
        document.getElementById('upload-form').reset();
        await loadDocuments();
        if (data.document) {
            activeDocumentId = data.document.file_id;
            activeDocument = data.document;
            renderOverview(activeDocument);
            renderMarkdown(activeDocument);
            renderLogs(activeDocument);
            renderChunkPreview(activeDocument);
            renderChatHistoryWithAttachments(activeDocument.state?.chat_history || []);
            populateConfigForm(activeDocument);
            await loadPhase1Summary(activeDocumentId);
            subscribeToLogs(activeDocumentId);
            setWorkflowTabsEnabled(true);
            showTab('#tab-chunking');
            highlightActiveDocument();
        }
    } catch (err) {
        alert(`Ingestion failed: ${err.message}`);
    }
}

async function uploadLocalFile() {
    if (!fileUploadInput.files || !fileUploadInput.files.length) {
        alert('Please select a file to upload');
        return;
    }
    const file = fileUploadInput.files[0];
    const formData = new FormData();
    formData.append('file', file);
    uploadStatus.textContent = 'Uploading...';
    uploadButton.disabled = true;
    try {
        const res = await fetch('/api/doc_review/upload', {
            method: 'POST',
            body: formData
        });
        if (!res.ok) {
            const err = await res.json();
            throw new Error(err.error || res.statusText);
        }
        const data = await res.json();
        uploadStatus.textContent = `‚úÖ Uploaded: ${data.original_filename || file.name}`;
        
        // Refresh dropdown and select the uploaded file
        await loadUploadDirFiles();
        if (selectDocumentDropdown) {
            selectDocumentDropdown.value = data.saved_path;
            await handleDocumentSelect();
        }
        
        fileUploadInput.value = '';
    } catch (err) {
        console.error('Upload failed', err);
        uploadStatus.textContent = `‚ùå Upload failed: ${err.message}`;
        alert(err.message || 'Upload failed');
    } finally {
        fileUploadInput.value = '';
        uploadButton.disabled = false;
    }
}

// Handle text selection in markdown editor
function handleMarkdownSelection() {
    if (!markdownEditor) {
        if (btnAttachSelection) btnAttachSelection.disabled = true;
        return;
    }
    
    // Check if editor is disabled
    if (markdownEditor.disabled) {
        if (btnAttachSelection) {
            btnAttachSelection.disabled = true;
            btnAttachSelection.title = 'Enable markdown editor first (run Phase 4)';
        }
        return;
    }
    
    // Check if there's a selection
    const start = markdownEditor.selectionStart || 0;
    const end = markdownEditor.selectionEnd || 0;
    const hasSelection = end > start;
    
    if (btnAttachSelection) {
        btnAttachSelection.disabled = !hasSelection;
        if (hasSelection) {
            const selectedText = markdownEditor.value.slice(start, end);
            btnAttachSelection.title = `Attach selected text (${selectedText.length} chars)`;
        } else {
            btnAttachSelection.title = 'Select text in markdown editor to attach';
        }
    }
    
    // Visual feedback: show selection length in console (for debugging)
    if (hasSelection) {
        const selectedText = markdownEditor.value.slice(start, end);
        console.debug('Text selected:', selectedText.length, 'characters');
    }
}

// Attach selected text from markdown editor
function attachSelectedText() {
    if (!markdownEditor) {
        alert('Markdown editor not available');
        return;
    }
    
    if (markdownEditor.disabled) {
        alert('Please run Phase 4 first to enable the markdown editor');
        return;
    }
    
    const start = markdownEditor.selectionStart || 0;
    const end = markdownEditor.selectionEnd || 0;
    
    if (end <= start) {
        alert('Please select some text first');
        return;
    }
    
    attachedText = markdownEditor.value.slice(start, end).trim();
    if (!attachedText) {
        alert('Selected text is empty');
        return;
    }
    
    // Show attached text display
    const preview = attachedText.length > 200 ? attachedText.substring(0, 200) + '...' : attachedText;
    if (attachedTextPreview) {
        attachedTextPreview.textContent = preview;
    }
    if (attachedTextDisplay) {
        attachedTextDisplay.style.display = 'block';
    }
    
    // Visual feedback
    console.log('Text attached:', attachedText.length, 'characters');
    
    // Focus chat input
    const chatInput = document.getElementById('inputChat');
    if (chatInput) {
        chatInput.focus();
    }
}

// Remove attached text
function removeAttachedText() {
    attachedText = '';
    if (attachedTextDisplay) {
        attachedTextDisplay.style.display = 'none';
    }
    if (attachedTextPreview) {
        attachedTextPreview.textContent = '';
    }
    // Clear selection in markdown editor
    if (markdownEditor && markdownEditor.setSelectionRange) {
        markdownEditor.setSelectionRange(markdownEditor.selectionStart, markdownEditor.selectionStart);
    }
}

async function submitChat(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    
    if (!activeDocumentId) {
        alert('Please select a document first (use Phase 4 dropdown or Phase 1 selection).');
        return;
    }
    
    const chatInput = document.getElementById('inputChat');
    if (!chatInput) {
        alert('Chat input not found');
        return;
    }
    
    const message = chatInput.value.trim();
    if (!message) {
        alert('Please enter a message');
        return;
    }
    
    // Use attached text if available, otherwise check for current selection
    let selectedText = attachedText || '';
    if (!selectedText && markdownEditor && !markdownEditor.disabled && typeof markdownEditor.selectionStart === 'number') {
        const start = markdownEditor.selectionStart;
        const end = markdownEditor.selectionEnd;
        if (end > start) {
            selectedText = markdownEditor.value.slice(start, end).trim();
        }
    }
    
    const payload = { message };
    if (selectedText) {
        payload.selected_text = selectedText;
        console.log('Sending chat with attachment:', selectedText.length, 'characters');
    }
    
    // Show user message with attachment indicator (optimistic update)
    const userMessage = {
        role: 'user',
        content: message,
        message: message, // Also include 'message' field for backward compatibility
        selection: selectedText ? selectedText.substring(0, 100) + (selectedText.length > 100 ? '...' : '') : null,
        selected_text: selectedText ? selectedText.substring(0, 100) : null,
        timestamp: new Date().toISOString()
    };
    if (!activeDocument) activeDocument = {};
    if (!activeDocument.state) activeDocument.state = {};
    if (!activeDocument.state.chat_history) activeDocument.state.chat_history = [];
    activeDocument.state.chat_history.push(userMessage);
    renderChatHistoryWithAttachments(activeDocument.state.chat_history);
    
    // Clear input and attachment
    chatInput.value = '';
    removeAttachedText();
    
    // Show loading indicator
    const submitBtn = chatInput.form?.querySelector('button[type="submit"]');
    if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
    }
    
    try {
        console.log('Sending chat request to:', `/api/doc_review/chat/${activeDocumentId}`);
        const res = await fetch(`/api/doc_review/chat/${activeDocumentId}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        
        console.log('Chat response status:', res.status);
        
        if (!res.ok) {
            const err = await res.json().catch(() => ({ error: res.statusText }));
            throw new Error(err.error || res.statusText);
        }
        
        const data = await res.json();
        console.log('Chat response data:', data);
        console.log('Response text:', data.response);
        console.log('Chat history:', data.chat_history);
        
        // Update chat history with the response from server
        if (!activeDocument) activeDocument = {};
        if (!activeDocument.state) activeDocument.state = {};
        
        // Use server's chat_history if available, otherwise manually add the response
        if (data.chat_history && Array.isArray(data.chat_history)) {
            activeDocument.state.chat_history = data.chat_history;
        } else {
            // Fallback: manually add response if chat_history is not in expected format
            if (!activeDocument.state.chat_history) {
                activeDocument.state.chat_history = [];
            }
            // The user message was already added optimistically, now add the assistant response
            if (data.response) {
                activeDocument.state.chat_history.push({
                    role: 'assistant',
                    content: data.response,
                    response: data.response,
                    timestamp: new Date().toISOString()
                });
            }
        }
        
        renderChatHistoryWithAttachments(activeDocument.state.chat_history);
        
        // Reload document to sync state
        const docRes = await fetch(`/api/doc_review/documents/${activeDocumentId}`);
        if (docRes.ok) {
            const docData = await docRes.json();
            activeDocument = docData.document || activeDocument;
        }
    } catch (err) {
        console.error('Chat error:', err);
        alert(err.message || 'Chat service unavailable. Please check if LLM is configured.');
        // Remove failed message from history
        if (activeDocument && activeDocument.state && activeDocument.state.chat_history) {
            activeDocument.state.chat_history.pop();
            renderChatHistoryWithAttachments(activeDocument.state.chat_history);
        }
    } finally {
        // Restore submit button
        if (submitBtn) {
            submitBtn.disabled = false;
            submitBtn.innerHTML = '<i class="bi bi-send"></i>';
        }
    }
}

// Event bindings
document.getElementById('btn-refresh').addEventListener('click', loadDocuments);
// Event listeners for new simplified UI
if (selectDocumentDropdown) {
    selectDocumentDropdown.addEventListener('change', handleDocumentSelect);
}
if (btnRefreshDocList) {
    btnRefreshDocList.addEventListener('click', loadUploadDirFiles);
}
if (selectDocumentPhase2) {
    selectDocumentPhase2.addEventListener('change', handlePhase2DocumentSelect);
}
if (selectDocumentPhase3) {
    selectDocumentPhase3.addEventListener('change', handlePhase3DocumentSelect);
}
// Handle Phase 2 tab click to load documents and enable selection
if (tabControls.chunking) {
    tabControls.chunking.addEventListener('click', async (e) => {
        // Only handle if tab is actually clicked (not just programmatic show)
        if (!tabControls.chunking.disabled) {
            await handlePhase2TabClick();
        }
    });
}
// Handle Phase 3 (Analysis) tab click to load documents and enable selection
if (tabControls.analysis) {
    tabControls.analysis.addEventListener('click', async (e) => {
        // Only handle if tab is actually clicked (not just programmatic show)
        if (!tabControls.analysis.disabled) {
            await handlePhase3TabClick();
        }
    });
}
// Update estimated count when context level or threshold changes
document.getElementById('selectContextLevel')?.addEventListener('change', updateEstimatedChunkCount);
document.getElementById('inputPageThreshold')?.addEventListener('input', updateEstimatedChunkCount);
if (btnRunPhase1) {
    btnRunPhase1.addEventListener('click', runPhase1Workflow);
}
if (btnRefreshProcessed) {
    btnRefreshProcessed.addEventListener('click', loadDocuments);
}

// Legacy form (can be removed or hidden)
const uploadForm = document.getElementById('upload-form');
if (uploadForm) {
    uploadForm.addEventListener('submit', ingestDocument);
}
document.getElementById('btn-save-config').addEventListener('click', patchConfig);
document.getElementById('btn-run')?.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopPropagation();
    runWorkflow(e);
});
document.getElementById('config-form').addEventListener('submit', evt => evt.preventDefault());
document.getElementById('chat-form').addEventListener('submit', submitChat);

// Attach selection button
if (btnAttachSelection) {
    btnAttachSelection.addEventListener('click', attachSelectedText);
}

// Remove attachment button
if (btnRemoveAttachment) {
    btnRemoveAttachment.addEventListener('click', removeAttachedText);
}

// Listen for text selection in markdown editor
if (markdownEditor) {
    markdownEditor.addEventListener('mouseup', handleMarkdownSelection);
    markdownEditor.addEventListener('keyup', handleMarkdownSelection);
    markdownEditor.addEventListener('select', handleMarkdownSelection);
}

// Phase 4 document selection and run button
if (selectDocumentPhase4) {
    selectDocumentPhase4.addEventListener('change', handlePhase4DocumentSelect);
}
if (btnRunPhase4) {
    btnRunPhase4.addEventListener('click', runPhase4Workflow);
}

// Handle Phase 4 tab click
const tabButtonReview = document.getElementById('tabButtonReview');
if (tabButtonReview) {
    tabButtonReview.addEventListener('click', handlePhase4TabClick);
}
templatesSelect.addEventListener('change', evt => refreshTemplatePreview(evt.target.value));
uploadButton.addEventListener('click', uploadLocalFile);

// Handle Proceed to Phase 2 button (event delegation for dynamically created buttons)
document.addEventListener('click', function(e) {
    if (e.target && (e.target.id === 'btnProceedPhase2' || e.target.closest('#btnProceedPhase2'))) {
        e.preventDefault();
        proceedToPhase2();
    }
    
    // Handle heading filter buttons
    if (e.target && e.target.classList.contains('heading-filter-btn')) {
        e.preventDefault();
        const filterLevel = e.target.dataset.filter;
        filterHeadings(e.target, filterLevel);
    }
});

// Filter headings by level
function filterHeadings(clickedBtn, filterLevel) {
    // Update button states
    const btnGroup = clickedBtn.closest('.btn-group');
    if (btnGroup) {
        btnGroup.querySelectorAll('.heading-filter-btn').forEach(btn => {
            if (btn === clickedBtn) {
                btn.classList.add('active');
                btn.style.backgroundColor = '#003DA5';
                btn.style.color = 'white';
                btn.style.borderColor = '#003DA5';
            } else {
                btn.classList.remove('active');
                btn.style.backgroundColor = '#E6F2FF';
                btn.style.color = '#003DA5';
                btn.style.borderColor = '#CCE5FF';
            }
        });
    }
    
    // Find the markdown display element (search in parent containers)
    let container = clickedBtn.closest('.mb-3');
    if (!container) {
        container = clickedBtn.closest('.card');
    }
    if (!container) {
        container = clickedBtn.closest('[class*="mb-3"]');
    }
    
    const markdownDisplay = container ? container.querySelector('.heading-markdown-display') : null;
    if (markdownDisplay) {
        try {
            const headingStructure = JSON.parse(markdownDisplay.dataset.headings || '[]');
            const filteredMarkdown = generateHeadingMarkdown(headingStructure, filterLevel);
            markdownDisplay.textContent = filteredMarkdown;
        } catch (err) {
            console.error('Failed to filter headings:', err);
        }
    } else {
        console.warn('Could not find markdown display element');
    }
}

// Proceed to Phase 2 - navigate to chunking tab and maintain state
// Can be called even without active document (will allow selection in dropdown)
async function proceedToPhase2() {
    // Load Phase 2 documents (documents with Phase 1 completed)
    await loadPhase2Documents();
    
    // Switch to Phase 2 tab (Chunking)
    showTab('#tab-chunking');
    
    // Enable Phase 2 tab
    if (tabControls.chunking) {
        tabControls.chunking.disabled = false;
        tabControls.chunking.classList.remove('disabled');
    }
    
    // If there's an active document with Phase 1 completed, use it
    if (activeDocumentId && activeDocument) {
        const state = activeDocument.state || {};
        const hasPhase1 = state.phase1_stats || state.phase1_report || 
                         (state.file_metadata && state.file_metadata.page_count);
        
        if (hasPhase1) {
            // Enable chunking controls
            toggleConfigFieldsets(true);
            
            // Ensure document state is loaded and displayed
            renderOverview(activeDocument);
            renderMarkdown(activeDocument);
            renderLogs(activeDocument);
            renderChunkPreview(activeDocument);
            await populateConfigForm(activeDocument);
            await updateEstimatedChunkCount();
            highlightActiveDocument();
            setWorkflowTabsEnabled(true);
        } else {
            // Document doesn't have Phase 1, clear active document in Phase 2
            if (selectDocumentPhase2) {
                selectDocumentPhase2.value = '';
            }
            toggleConfigFieldsets(false);
            estimatedChunksInput.value = '';
        }
    } else {
        // No active document, allow selection from dropdown
        // Controls will be enabled when document is selected
        toggleConfigFieldsets(false);
    }
    
    console.log('Proceeding to Phase 2');
}

// Handle Phase 2 document selection
async function handlePhase2DocumentSelect() {
    const selectedFileId = selectDocumentPhase2?.value;
    if (!selectedFileId) {
        toggleConfigFieldsets(false);
        estimatedChunksInput.value = '';
        // Clear active document if deselected
        if (!selectedFileId) {
            activeDocumentId = null;
            activeDocument = null;
        }
        return;
    }
    
    // Load the selected document
    await selectDocument(selectedFileId);
    
    // Verify it has Phase 1 data
    if (activeDocument) {
        const state = activeDocument.state || {};
        const hasPhase1 = state.phase1_stats || state.phase1_report || 
                         (state.file_metadata && state.file_metadata.page_count);
        
        if (!hasPhase1) {
            alert('This document does not have Phase 1 data. Please run Phase 1 first.');
            selectDocumentPhase2.value = '';
            toggleConfigFieldsets(false);
            return;
        }
    }
    
    // Update estimated chunk count
    await updateEstimatedChunkCount();
    
    // Enable chunking controls
    toggleConfigFieldsets(true);
    
    // Enable workflow tabs
    setWorkflowTabsEnabled(true);
}

// Check if Phase 2 is available (documents with Phase 1 completed exist)
async function checkPhase2Availability() {
    try {
        const res = await fetch('/api/doc_review/documents');
        const data = await res.json();
        
        if (Array.isArray(data.documents)) {
            // Check if any documents have Phase 1 completed
            const hasPhase1Completed = data.documents.some(doc => {
                const state = doc.state || {};
                return state.phase1_stats || state.phase1_report || 
                       (state.file_metadata && state.file_metadata.page_count);
            });
            
            if (hasPhase1Completed) {
                // Enable Phase 2 tab if documents with Phase 1 data exist
                if (tabControls.chunking) {
                    tabControls.chunking.disabled = false;
                    tabControls.chunking.classList.remove('disabled');
                }
                // Load Phase 2 documents into dropdown
                await loadPhase2Documents();
            } else {
                // Disable Phase 2 tab if no documents with Phase 1 exist
                if (tabControls.chunking) {
                    tabControls.chunking.disabled = true;
                    tabControls.chunking.classList.add('disabled');
                }
            }
            
            // Check Phase 3 availability (documents with Phase 2 completed)
            await checkPhase3Availability();
        }
    } catch (err) {
        console.error('Failed to check Phase 2 availability:', err);
    }
}

// Check if Phase 3 is available (documents with Phase 2 completed exist)
async function checkPhase3Availability() {
    try {
        const res = await fetch('/api/doc_review/documents');
        const data = await res.json();
        
        if (Array.isArray(data.documents)) {
            // Check if any documents have Phase 2 completed (have index.sections)
            const hasPhase2Completed = data.documents.some(doc => {
                const state = doc.state || {};
                return state.index && state.index.sections && state.index.sections.length > 0;
            });
            
            if (hasPhase2Completed) {
                // Enable Phase 3 (Analysis) tab if documents with Phase 2 data exist
                if (tabControls.analysis) {
                    tabControls.analysis.disabled = false;
                    tabControls.analysis.classList.remove('disabled');
                }
                // Load Phase 3 documents into dropdown
                await loadPhase3Documents();
                // Auto-select first Phase 2 document if none selected
                if (selectDocumentPhase3 && !selectDocumentPhase3.value) {
                    autoSelectPhase3Document();
                }
            } else {
                // Disable Phase 3 tab if no documents with Phase 2 exist
                if (tabControls.analysis) {
                    tabControls.analysis.disabled = true;
                    tabControls.analysis.classList.add('disabled');
                }
            }
        }
    } catch (err) {
        console.error('Failed to check Phase 3 availability:', err);
    }
}

// Load documents for Phase 3 dropdown (documents that have Phase 2 completed)
async function loadPhase3Documents() {
    if (!selectDocumentPhase3) return;
    
    try {
        const res = await fetch('/api/doc_review/documents');
        const data = await res.json();
        
        selectDocumentPhase3.innerHTML = '<option value="">-- Select a document --</option>';
        
        if (Array.isArray(data.documents)) {
            // Filter documents that have Phase 2 completed (have index.sections)
            const phase2Completed = data.documents.filter(doc => {
                const state = doc.state || {};
                return state.index && state.index.sections && state.index.sections.length > 0;
            });
            
            if (phase2Completed.length === 0) {
                // No documents with Phase 2, add placeholder
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = 'No documents with Phase 2 completed';
                placeholder.disabled = true;
                selectDocumentPhase3.appendChild(placeholder);
                return;
            }
            
            // Add documents to dropdown
            phase2Completed.forEach(doc => {
                const option = document.createElement('option');
                option.value = doc.file_id;
                option.textContent = doc.file_id || 'Unknown';
                selectDocumentPhase3.appendChild(option);
            });
        }
    } catch (err) {
        console.error('Failed to load Phase 3 documents:', err);
    }
}

// Auto-select first Phase 2 document for Phase 3
async function autoSelectPhase3Document() {
    if (!selectDocumentPhase3) return;
    
    const options = Array.from(selectDocumentPhase3.options);
    const firstValidOption = options.find(opt => opt.value && !opt.disabled);
    
    if (firstValidOption) {
        selectDocumentPhase3.value = firstValidOption.value;
        // Trigger document selection
        handlePhase3DocumentSelect();
    }
}

// Handle Phase 3 document selection
async function handlePhase3DocumentSelect() {
    const fileId = selectDocumentPhase3?.value;
    if (!fileId) {
        // No document selected, disable controls
        toggleConfigFieldsets(false);
        document.getElementById('btn-run').disabled = true;
        activeDocumentId = null;
        activeDocument = null;
        return;
    }
    
    // Set as active document
    activeDocumentId = fileId;
    
    // Load document
    try {
        const res = await fetch(`/api/doc_review/documents/${fileId}`);
        const data = await res.json();
        if (!data.document) return;
        
        activeDocument = data.document;
        populateConfigForm(activeDocument);
        renderChunkPreview(activeDocument.state);
        await loadPhase3Summary(fileId);
        subscribeToLogs(fileId);
        
        // Enable controls
        toggleConfigFieldsets(true);
        document.getElementById('btn-run').disabled = false;
    } catch (err) {
        console.error('Failed to load Phase 3 document:', err);
        alert(`Failed to load document: ${err.message}`);
    }
}

// Handle direct click on Phase 2 tab (even without active document)
async function handlePhase2TabClick() {
    // Load Phase 2 documents if not already loaded
    await loadPhase2Documents();
    
    // If no document is selected, allow user to select from dropdown
    if (!selectDocumentPhase2?.value) {
        toggleConfigFieldsets(false);
    } else {
        // Document is selected, enable controls
        toggleConfigFieldsets(true);
        await updateEstimatedChunkCount();
    }
}

// Handle direct click on Phase 3 (Analysis) tab (even without active document)
async function handlePhase3TabClick() {
    // Load Phase 3 documents if not already loaded
    await loadPhase3Documents();
    
    // If no document is selected, auto-select first one or allow user to select
    if (!selectDocumentPhase3?.value) {
        await autoSelectPhase3Document();
    }
    
    // If still no document, disable controls
    if (!selectDocumentPhase3?.value) {
        toggleConfigFieldsets(false);
        document.getElementById('btn-run').disabled = true;
    } else {
        // Document is selected, ensure controls are enabled
        if (!activeDocumentId) {
            await handlePhase3DocumentSelect();
        }
    }
}

// Initialize on page load
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', async () => {
        await loadUploadDirFiles();
        await loadDocuments();
        await checkPhase2Availability(); // This also checks Phase 3 availability
    });
} else {
    loadUploadDirFiles();
    loadDocuments();
    checkPhase2Availability(); // This also checks Phase 3 availability
}
markdownEditor.addEventListener('input', () => {
    if (markdownEditor.disabled) return;
    markdownDirty = true;
    saveMarkdownButton.disabled = markdownEditor.value.trim().length === 0;
});
saveMarkdownButton.addEventListener('click', saveMarkdown);
    renderChatHistoryWithAttachments([]);
// Initially disable workflow tabs - will be enabled if documents exist or when document is selected
setWorkflowTabsEnabled(false);
toggleConfigFieldsets(false);
// Note: Phase 2 tab may be enabled by checkPhase2Availability() if documents with Phase 1 exist

if (typeof socket !== 'undefined' && socket) {
    socket.on('authenticated', data => {
        if (data && data.success && pendingLogRoom) {
            joinDocLogRoom(pendingLogRoom);
        }
    });
    socket.on('connect', () => {
        ensureSocketToken().then(() => {
            if (isAuthenticated && currentLogRoom) {
                joinDocLogRoom(currentLogRoom);
            } else if (isAuthenticated && pendingLogRoom) {
                joinDocLogRoom(pendingLogRoom);
            }
        });
    });
    socket.on('doc_review:log', handleDocReviewLog);
    socket.on('doc_review:status', handleDocReviewStatus);
    socket.on('doc_review:error', data => {
        if (!data) return;
        liveLogs.push(
            normaliseLogEntry({
                node: 'socket',
                message: data.error || 'WebSocket error',
                level: 'error',
                timestamp: data.timestamp,
            })
        );
        updateLogsPanel();
    });
}

// Initial load
ensureSocketToken().finally(() => {
    loadTemplates().then(loadDocuments);
});
</script>
{% endblock %}
